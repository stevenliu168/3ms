http://3ms.huawei.com/km/blogs/details/5451121

从面向对象设计到领域驱动设计，再到服务化的设计过程
日期：2018-04-21 08:46浏览：2551评论：7
前言
在进行系统架构设计和软件架构设计中，会有很多方法论给我们选择，包括传统的过程式设计，面向对象设计，还有领域驱动设计和服务化设计。 下面我们将从软件本身的复杂性和非功能需求的复杂性来讨论：如何面对这种复杂性，如何解决这种复杂性，如何去选择适合团队的软件设计方法论。

软件固有的复杂性带来的软件架构设计和实现的复杂性
我们都知道软件都是用来解决某个问题域的，比如电信领域，电商领域等等，那么这个领域的业务复杂性会对软件架构带来固有的复杂性。
比如我们要实现一个简单的学生管理系统，那么通过简单的OO分析就可以实现出来，但是要实现一个复杂的类似于淘宝的电商，考虑用户的管理，商品的管理，支付的管理，这样就导致了软件架构的复杂性和工作量的上升
第二点就是需求提出者，系统设计师和软件开发人员对于业务知识的理解和传递，业务专家有业务语言，程序员有自己的技术语言，在这一点上面就可能导致理解误差。-
第三点就是产品的一些额外属性：比如性能要求比较高，时延比较低，运维部署比较简单，支持快速部署上线，这些非功能性需求往往对于软件架构带来更大的挑战。
所以，从一个简单的系统到一个复杂的系统，我们选用的软件架构设计方案论是可能有差异的，但是最终目标是为了最简单快速地实现我们的系统，并且可以完成各种架构属性指标。

image.png

面向对象的设计与实现
面向对象是一种编程范式，学过Java、C++的都知道这个东西。我们也都知道面向对象是为了更好地解决模块化问题，提高系统模块的高内聚和低耦合，而不是过程式编程那样，算法和数据分离，导致重复代码，高耦合代码，最终难以维护和扩展。

我们来看看面向对象核心思想是什么：
抽象，封装，继承和多态。 通过这些手段我们保证系统中每一个单元（类）都是高内聚的，单元之间都是低耦合的。 通过这些手段来逐步封装我们的业务。

关于如何做好面向对象设计，不是这里讨论的话题，只要掌握好了软件模块设计基本方法，比如SOLID原则，正交设计以及常见的面向对象建模方法（UML建模），GoF的设计模式。这些都可以支撑一个好的OO建模与设计。
但是有一点要注意：面向对象不是目的，而是手段

总结：

面向对象设计是解决什么问题的？
编码的本质其实就是层次化分解与重新组合的过程。对于程序的组合而言， 什么样的代码才是更好的： 代码的表面积必须要比它们的体积增长的更为缓慢。
代码块的表面积是是我们复合代码块时所需要的信息。代码块的体积 是我们为了实现它们所需要的信息。一旦代码块的实现过程结束，我们就可以忘掉它的实现细节，只关心它与其他代码块的相互影响。在面向对象编程中，类或接口的声明就是表面。在函数式编程中，函数的声明就是表面。（上述请参加《函数式编程与面向对象编程[5]:编程的本质》）
怎样才能做到表面积增长速度小于体积增长速度？当然是分解，信息隐藏，抽象。而这些也正是面向对象所追求和擅长的。
面向对象主要目的是为了模块化。　软件工业最近20年来，能够构建如此大规模的需求频繁变化的软件系统，很大程度上得益于面向对象对于模块化的良好支持。而现在风头正劲的微服务化，无非是把模块化的思想，从进程内模块（类），变为进程间而已。

面向对象设计什么问题是很难解决的？
面向对象的抽象层次是基于编程语言的，语言提供了class，extends来进行模块化，这种建模方式对于简单系统是比较容易的，但是对于非常复杂的业务系统的时候，你直接通过OOAD去进行架构设计，将会特别困难，因为OOAD是面向最底层的抽象，无法应对大量的对象的设计。

领域驱动设计
我们从前面了解到，对于一个复杂的系统，如果用纯粹的OOAD是很难进行软件架构设计的，我们必须使用更高层次的抽象和系统的分层，所以就有了Evans的《领域驱动设计：软件核心复杂性应对之道》，提出了领域驱动设计，提出了领域建模和设计的方法指导。

领域驱动设计的核心思想如下：

消化知识：通过领域模型建立过程中，将业务专家，架构师，开发人员，测试人员进行模型统一。
建立统一的语言：通过统一业务语言，消除团队之间的交流障碍，让代码表达的业务含义更明确
将模型和实现绑定：软件实现和领域模型高度一致，用统一的模型来指导开发设计，不要像传统那样有分析模型，设计模型和代码模型，完全分离，无法理解。
确定产品中各个领域，划分边界：通过分析系统中独立子域，进行隔离，每个子域独立发展。
image.png

领域驱动设计的技术要素
领域驱动设计的中的模型关系，对于这个模型我的看法就是当做优秀实践来参考，灵活选择，不要生搬硬套。并且我们在面向对象设计里面也有很多类似的思想，只是DDD中进行的专门的名词包装
image.png

领域驱动设计参考架构：分层架构：通过分层达到层次之间的解耦，并且最重要的就是领域层，领域对象如何构造。推荐使用面向对象的充血模型（但是要避免上帝类），而不要使用过程式的贫血模型
image.png
上面这个是一个典型的DDD分层架构，还有一些改进的，比如六边形架构，洋葱架构等。

我们从实际的实施策略来看， DDD给与团队的价值更适合为一种管理手段，通过统一领域模型将团队聚集起来，让团队中各个角色（从业务到开发测试）都能够采用统一的架构语言，从而避免组件划分过程中的边界错位, 并且让业务架构和系统架构形成绑定关系，从而建立针对业务变化的高响应力架构。

但是到了服务化以后，领域驱动设计对于服务的划分又成为了一种利器。

领域驱动设计和面向对象有什么关系？
没有关系，只能说由于现在编程语言以OO为主，所以领域驱动设计后的聚合，实体，领域服务都会基于面向对象来进行设计和实现。但是在领域驱动设计中又借助了OO或者模块化的思想，比如实体，聚合根，Bounded Context封装这些概念。
在领域驱动设计中，我们一切都是以领域对象为中心来进行业务描述的，然后确定我们的领域模型。但是一旦开始进行技术实现，那么就会切换到与领域无关的软件技术上面。
比如：

我们在DDD中会使用Repository，这样是为了模型只关注业务对象的获取，不用关心后面的技术细节。但是到了具体实现，我们可能会使用DAO或者ORM来进行Repository，这个时候就跳出了领域模型，而是更关注技术层面。
在DDD中，我们会有聚合根，实体，值对象。实体与面向对象中的概念类似，在领域模型中，实体应该具有唯一的标识符，从设计的一开始就应该考虑实体，决定是否建立一个实体也是十分重要的。但是最终这些领域对象通过什么编程语言实现，通过什么编程范式实现，那就是具体的技术关注点。已经不再DDD的领域模型考虑范围之内。
在领域驱动设计中，有贫血模型和充血模型，那么贫血模型就类似于一种面向过程式的编程风格，充血模型就是一种传统的面向对象编程风格。具体如何选择，可以参考DCI架构做更好的设计。

领域驱动设计VS数据驱动设计
image.png
上图的左边就是典型的数据驱动设计，先通过数据模型建模，形成DAO层，然后将DAO返回的PO进行行为赋予，最终业务层。整个设计都是面向数据的，数据和行为是明显分离的。右边就是领域驱动设计，按照业务领域来进行设计，包括领域对象和行为，至于领域对象如何存储那就是基础设施层考虑的事情了。所以领域驱动设计是面向业务的一种设计模型。

image.png

当软件在开发初期，以数据驱动的架构方式非常容易上手，但是随着业务的增长和项目的推进，软件开发和维护难度急剧升高。
领域驱动设计则在项目初期就处在一个比较难以上手的位置，但是随着业务的增长和项目的推进，软件开发和维护难度平滑上升。
数据驱动的典型特点就是先进行数据库建模，然后出现一堆DAO，然后上层业务通过调用不同的DAO完成具体的业务。这样的缺点就是DAO其实是一种技术实现，上面有数据存储的接口（数据更新update）。

但是对于领域驱动设计来说，会使用Repository来解决这个问题，这个就让领域层只关心领域对象，对于具体的数据访问细节不关心。
image.png

领域驱动设计的适用场景
但是要注意一点：软件开发中没有银弹，领域驱动设计也是如此：

领域驱动设计只有应用到大型系统才有较好的收益比，
领域驱动设计的要求较高，普通团队不一定能够掌握。
服务化设计的理念
我们在前面通过领域驱动设计可以实现一个满足领域模型的单体应用，但是随着业务的增加，可能会出现下面的问题：

逻辑复杂、模块耦合、代码臃肿，修改难度大，版本迭代效率低下
系统启动慢，一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动、重启时间周期过长
系统错误隔离性差、可用性差，任何一个模块的错误均可能造成整个系统的宕机
可伸缩性差；系统的扩容只能只对这个应用进行扩容，不能做到对某个功能点进行扩容
线上问题修复周期长；任何一个线上问题修复需要对整个应用系统进行全面升级
简单来说，无论是面向对象设计，还是领域驱动设计，都是基于某个层面的逻辑抽象而已，但是很多场景却需要使用物理隔离才能才能解决问题，这也就是分布式系统的作用，也就是服务化所追求的。

分布式系统固有的复杂性
分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
从一个单节点分成多个协同节点，那么势必会带来诸多复杂性：比如节点之间的数据一致性，数据传输性能，节点可靠性，整个系统的运维等。这些都是分布式系统，也就是服务化架构需要面对的问题。

服务化的技术要素
需要使用分布式框架
服务之间的传输协议：RPC， Restful，序列化与反序列化
负载均衡
服务注册，服务发现，服务治理
领域驱动设计与服务化的关系
领域驱动设计可以通过识别界限上下文，来完成服务的边界划分。
划分服务边界以后，对于每个服务的内部，可以继续采用DDD来进行分层架构设计, 也可以采用其他的方式来实现。
面向对象与服务化设计的关系
这个就更没有关系了，服务化拆分好了以后，服务内部使用DDD来实现也可以，如果是微服务，都不用DDD。只是通过OO实现就可以，也可以使用过程式或者函数是编程。但是回到本质上面，服务的划分和对象的划分其实又是采用同样的思路：高内聚低耦合。

总结
面向对象设计是软件设计的一种基础方法，与此对应有面向过程，面向函数式。这种是一种语言范式层面的设计方法，适用于小规模产品。（我们也可以把OO扩大到模块化的编程思想，那么就是通用软件设计方法论了，这里我们将OO就是狭义的基于OOP的方法）
领域驱动设计是面向领域的更高层面的抽象，从业务领域来进行设计，然后进行子域划分，降低子域之间的关联复杂性。
服务化设计是一种以分布式技术为基础的，进行物理隔离的软件设计方法。
这三者之间互相补充，尤其是面向对象设计，无论是顶层设计如何抽象，底层实现的时候都可以选用面向对象来实现。

有一句话要说一下：面向对象设计中的抽象和封装是软件架构设计的基础，如果连几个类的关系都整理不好，什么DDD的子域划分，什么微服务化划分解耦，那更是不可能完成的。

所以，随着业务系统的复杂性提升，我们抽象和封装的层次越来越高，通过物理服务划分，逻辑领域划分来分离复杂性
，并且分离业务领域和技术领域，以此来满足软件架构多种维度的要求，但是对于团队和产品团队的要求也就越来越高。所以需要选择合适的软件架构设计方法，根据业务的复杂性和团队能力状况进行抉择。
