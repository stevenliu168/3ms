http://3ms.huawei.com/km/blogs/details/2152205

回归软件设计的本质

              --追求高内聚低耦合的软件

 

在讨论软件设计之前，我们首先讨论一下什么是软件，根本原因就是满足客户的需求，在实现需求的时候要快速交付功能，努力降低成本，这样才能追求软件的利润最大化。

那么怎么降低软件开发的成本，内在成本是无法降低，比如你选择了C语言，那么C语言本身的复杂性你是必须承受的，这个无法避免，但是很多其他的偶发成本可以进行优化。比如重复的代码，代码不好理解，冗余的代码。

所以我们软件设计就是要完成下面的事情



1      什么是正交性（Orthogonality）设计
“正交性”是从几何中借来的术语。如果两条直线相交成直角，他们就是正交的。用向量术语来说，这两条直线互不依赖。沿着某一条直线移动，该直线投影到另一条直线上的位置不变。



举一个数学上的例子，在图上的直线上面，直线上面的三个点都是X坐标在变化，Y左边永远不变。

在计算机领域，如果两个或者更多模块中的一个发生变化，不会影响其他模块。这些模块就是正交的。

举一个例子, 如果有两个模块，薪水计算模块和计算算法两个模块，如果每次算法发生改变都会影响薪水计算模块的修改，那么这两个模块不是正交的。但是每次修改算法都不影响薪水计算模块，那么这两个模块就是正交的。

2      什么是好的软件设计
最简单的一句话：一个满足“简单设计原则”的设计就是好设计。

Kent Beck提出的简单设计四原则是：

以下四个原则的重要程度依次降低。

1.  通过所有测试（Passes its tests）

满足客户的需求

2.  尽可能消除重复 (Minimizes duplication)

让你的代码重复最小

3.  尽可能清晰的表达 (Maximizes clarity)

让代码更容易理解

4.   尽可能的减少代码元素的数量 (Has fewer elements)

不实现多余的功能

一般来说是1>2>3>4, 但是也有认为是1>3>2>4。

对于消除重复和代码易读性这两个点，大家一直都争论不休，为什么经过分析，觉得消除重复比代码易读性优先级要高呢？这是因为代码易读性具有主观性，每个人，每个团队对于代码易读性的标准不一样，所以这个就比较难以衡量。但是代码的重复性是可以通过一些科学的方法来评估和判断的。

 

第1,3,4比较好理解，也比较好操作，但是对于第2点，如何消除重复，这个就有很多方法，也有可能我们消除重复以后模块之间耦合度更严重了。

所以Thoughtworks的高级咨询师袁英杰就提出了正交设计的四原则来指导如何消除重复：

1.  最小化重复： 不要重复自己（DRY）

2.  分离不同的变化方向： 分离关注点（SoC）

3.  缩小依赖范围： 最小知识原则（LKP）

4.  向着稳定的方向依赖： 针对接口编程

我们从上面4点可以看出来，这些都是我们模块设计和编码中可以执行的策略，这个可以涵盖了我们在软件设计和开发中的所有注意的地方。

 

3      软件设计的本质
 我们软件设计的本质到底是什么，其实就是为了追求高内聚低耦合的软件架构，可以在每一次需求变化的时候只有局部化影响。

那么如何理清楚“高内聚低耦合”，“正交四原则”， “SOLID原则“， “设计模式”之间的关系，让我们在软件设计和编码的时候聚焦最本质的东西，这样才能真正做出正交的系统。



 

我们一直说高内聚，低耦合，其实这个是很抽象的，如何实现高内聚低耦合系统，是没有实际的指导意义的。所以我们从根本出发，只要你的模块中出现了重复的部分，那么你的系统就不是高内聚低耦合的。

举一个例子，如果模块A和模块B有一块重复的代码段C，那么说明代码段C是具有内聚性，但是却分别放到了两个模块中，那么就破坏了高内聚。因为A和B拥有相同的代码C，那么A和B就因为C发生了耦合，这样就违背了低耦合。

这个时候的做法就是提取一个公共的模块C, 让A和B和模块C进行耦合，这样就消除了重复，产生了可重用的模块C。



 

所以消除重复可以提高系统的高内聚和低耦合性。

我们再看正交四原则：

1.  最小化重复

2.  分离不同的变化方向

3.  缩小依赖范围

4.  向着稳定的方向依赖

第一点和第二点主要是针对内聚性来说的，第三点和第四点主要是针对耦合性来说的。我们消除了重复，提高的内聚性；我们将变化点分离出去，那么分离的部分和原有部分各自更加内聚。但是消除重复以后，原有模块和新模块之间将出现耦合，如果设计的不好，那么这个耦合可能将不稳定，所以第三点和第四点就是降低这种耦合度，所以要暴露最小的接口给调用者，并且接口定义一定要是描述客户的需求，而不是因为内部实现而暴露出来的接口。

 

所以正交四原则就是为了如何消除重复，如何保证系统的高内聚和低耦合来服务的。并且正交四原则是通用设计原则，无论你是什么样的系统，什么样的语言来实现，都可以用来指导你的设计。

 

在面向对象领域，有著名的SOLID原则：

SRP

The Single Responsibility Principle

单一责任原则

OCP

The Open Closed Principle

开放封闭原则

LSP

The Liskov Substitution Principle

里氏替换原则

DIP

The Dependency Inversion Principle

依赖倒置原则

ISP

The Interface Segregation Principle

接口分离原则

 

我们可以仔细分析正交四原则和SOLID原则之间的关系。

正交四原则的第一点和第二点就是消除重复和分离变化方向，这样其实就是要保证单一职责和开放封闭。如果两个类出现了重复，就说明这两个类不止一个引起变化的原因了，重复的地方是一个，变化的地方是另外一个。只有把重复的部分编程重用，这样重用的部分暂时就是单一职责的，另外两个类也是单一职责的了。

 

对于分离变化方向，举一个例子：

我们代码中所有的if-else或者switch-case这样的代码：



首先这样的代码是一种重复，无论是进入哪一种case，都会重复上面和后面的代码，并且这样的代码代表一种变化方向，如果新增加一个case，那么这里的代码是需要修改。

所以我们需要分离变化方向，比如修改成这个样子：



这只是面向对象领域的一种实现方式，我们通过接口来隔离这种变化，对于这个系统来说，后续只需要扩展一个Shape出来，而不是修改这个方法就可以实现原有的功能，这就是所谓的开放封闭原则。从而也可以看出SOLID原则中的单一职责和开放封闭都是针对如何提高内聚性来说的。

 

我们再来看正交四原则的第三点和第四点，这个其实是描述了一种三方关系：



上面这个接口是一个广义的接口，可以是API， 枚举， 抽象类， Interface或者具体类。客户和实现之间通过一种稳定的接口来联系，客户和实现都依赖这个接口。客户要描述这个接口，告诉实现我需要什么，实现负责去实现这个接口，无论底层的实现怎么变化，对于客户应该是不用感知的。

 

缩小依赖范围就对应了接口分离原则，向着稳定的方向依赖对应了里氏替换原则和依赖倒置原则。 接口分离原则保证了客户不必要关注不需要的接口，里氏替换原则保证了替换任意实现都不会影响客户调用的行为，依赖导致原则保证了接口是稳定的，是不会随着底层实现的变化而发生变化的。所以SOLID的中的里氏替换，依赖倒置和接口分离是描述如何提高低耦合。

 

所以，从上面的分析来看，SOLID原则只是正交四原则在OO领域的另一种描述形式，归根接地，SOLID原则都是为了提高系统的高内聚和低耦合。

在SOLID的上面还有很多设计模式，这些设计模式大部分都是可以推导到背后的SOLID原则，比如策略模式就是OCP。

 

4      总结
本文主要演示了如何从高内聚低耦合得出了正交四原则，然后讲述了正交四原则和SOLID原则之间的关系。

 

从这个过程可以看出，软件设计设计本质就是高内聚低耦合，但是高内聚低耦合不具备可执行性，所以才有了正交四原则。所以后面我们在软件设计的时候，时时刻刻都需要想想自己的做出设计决策的时候是为了达到正交四原则的哪点要求。

我们可以不用记那么多的原则和模式，等我们真正了解正交四原则的时候，你会发现上面的那些原则和模式都是很自然的出现了。

 

所以我希望我们的软件架构师和软件工程师，在进行软件设计的时候，不要迷恋于某些技术，方法和工具，而是要回归到本质来，只有这样你的系统才会是一个真正简单的正交的系统。

 

那么本质是什么：就是正交四原则（高内聚低耦合的策略化）， 大家可以好好体会一下无论是面向对象，还是面向过程的设计，都可以用这四个原则来描述我们的设计方向。
