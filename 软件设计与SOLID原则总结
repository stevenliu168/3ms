http://3ms.huawei.com/km/blogs/details/8633925

软件设计与SOLID原则总结
日期：2020-07-24 08:50浏览：6130评论：0
软件设计原则
在《敏捷软件开发 原则、模式与实践》一书中，提出了SOLID原则和包的设计原则，用来解决软件设计的坏味道，和如何让软件快速去应对软件变化。

我们先简单回顾一下这些设计原则：

SOLID原则回顾
单一职责原则(SRP)
There should never be more than one reason for a class to change.
每个方法或类应当有且仅有一个变化的原因。这意味着每个方法或类应当做一件事情，或者只有一项职责。

单一职责，通过对变化原因的识别，将一个承担多重职责的类，不断分割为更小的，只具备单一变化原因的类。而单一变化原因指的是：一个变化，会引起整个类都发生变化。只有关联极其紧密的情况，才会导致这样的局面。因而，单一职责和高内聚某种程度是同义词。

开放封闭原则(OCP)
Software entities like classes, modules and functions should be open for extension but closed for modifications.
类，函数应当对扩展开放，对修改关闭。

如果程序中的一处改动就会导致多个相关模块的改动，也就是常说的散弹式修改， 这就是一种僵化的设计坏味道。我们需要追求的是对于扩展是开发的，对于更改是封闭的（Open for extension, Closed for modification）。

OCP看似不可能，其实是很简单的：关键一点就是分离变化方向，然后进行抽象。

里氏替换原则(LSP)
Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

简单地来说，就是父类出现的地方，换成任何子类也可以正常工作。

所以里氏替换原则强调的是契约式编程。

接口分离原则(ISP)
The dependency of one class to another one should depend on the smallest possible interface.
不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。

这个原则主要是用来处理所谓的胖(fat)接口的缺点的（客户可以使用不属于自己业务的其他接口，也就是接口污染）。 我们应该将接口进行分离，对外暴露应该是高内聚的一组一组的接口，而不应该作为单一的类暴露给外面。

依赖倒置原则(DIP)
High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.

高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象。
这个原则简单来说，就是面向接口编程，就是为了降低两个模块之间的耦合性，达到正交。

包的设计原则/组件构建原则
随着应用程序的规模和复杂度的增加，需要在更高的层次对它们进行组织。类对于小型应用程序来说事非常方便的组织单元，但是对于大型应用程序来 说，如果仅仅使用类作为唯一的组织单元，就会显得粒度过细。因此，就需要比类“大”的“东西”来辅助大型应用程序的组织。这个“东西”就是包 （package）。

包的内聚性原则
Reuse-Release Equivalence Principle (REP) 重用-发布等价原则
Common-Reuse Principle(CCP) 共同重用原则。
Common-Closure Principle(CRP)共同封闭原则。
这3个关于包的内聚性原则，可以帮助开发者决定如何把类划分到包中。
这些原则依赖于这样的事实：至少已经存在一些类，并且它们之间的相互关系也已经确定。
因此，这些原则是根据“自底向上”的观点对类进行划分的。

这些原则其实是存在竞争关系的，我们会根据项目的演进进行调整，来权衡这些原则：
image.png

包的耦合性原则
Acyclic-Dependency Principle(ADP) 无环依赖原则 。
Stable-Dependency Principle (SDP) 稳定依赖原则。
Stable-Abstractions Principle (SAP) 稳定抽象原则。
这3个包的耦合性原则，用来处理包之间的关系。
这里，我们会再次碰到可开发性与逻辑设计之间的冲突力（tension）。
来自技术和行政方面的作用力都会影响到包的组织结构，并且这种作用力还是易变的。

高内聚低耦合、正交四原则与SOLID的关系
如果还不了解正交设计的，请参考变化驱动：正交设计

image.png
我们来具体分析一下SOLID原则和正交四原则是如何满足高内聚和低耦合。

一个好的面向对象设计，自然是符合高内聚，低耦合原则的对象划分和协作方式。
单一职责和开放封闭，更多的在强调类划分时的高内聚；而里氏替换，依赖倒置，接口隔离则更多的强调类与类之间协作接口（即API）定义的低耦合。

高内聚 （模块怎么划分）
单一职责这个原则是没有告诉我们该如何判定一个类属于单一职责的，以及如何达到单一职责的状态。而策略消除重复，分离不同变化方向，正是让类达到单一职责的策略与途径。

消除重复达到单一职责：
image.png

分离变化方向达到单一职责：
image.png

低内聚 （模块怎么合并）
开放封闭原则，通过将不同变化方向进行分离，从而达到对于已经出现的变化方向，对于修改是封闭的，对于扩展是开放的。
image.png

里氏替换原则强调的是，一个子类不应该破坏其父类与客户之间的契约。唯有如此，才能保证：客户与其父类所暴露的接口（即API）所产生的依赖关系是稳定的。子类只应该成为隐藏在API背后的某种具体实现方式。
image.png

依赖倒置原则则强调：为了让依赖关系是稳定的，不应该由实现侧根据自己的技术实现方式定义接口，然后强迫上层（即客户）依赖这种不稳定的API定义，而是应该站在上层（即客户）的角度去定义API（正所谓依赖倒置）。但是，虽然接口由上层定义，但最终接口的实现却依然由下层完成，因此依赖倒置描述为：上层不依赖下层，下层也不依赖上层，双方共同依赖于抽象。
image.png

接口隔离原则强调的是：不应该强迫客户依赖它不需要的东西。显然，这是缩小依赖范围策略在面向对象范式下的产物。
image.png

对于软件模块化设计，我们追求的目的就是高内聚和低耦合，正交四原则和SOLID原则都是希望达到这个效果。面向对象是一种对模块化支持良好的范式。通过高内聚，低耦合原则，或正交策略的运用，SOLID原则会自然浮现。

如何更好地运用SOLID原则
SOLID原则和设计模式不是面向对象专用的，对于过程式编程和函数式编程也是同样适用的，我们应该深刻理解SOLID原则和设计模式是如何解决软件模块化问题，达到高内聚低耦合目标的。
其实我们在正交设计里面已经讲到了如何“分与合”模块，如果我们按照正交四原则来进行模块设计与重构，自然而然地达到了SOLID所要求的那样，也会很自然应用一些设计模式。
所以对于SOLID原则和设计模式，我们不应该生搬硬套，而是要理解软件设计的目的，才能更好灵活运用。
我们耳熟能详的软件设计相关原则，模式与实践的关系如下：
image.png
所以高内聚低耦合是我们软件设计追求的目标，SOLID原则提出了如何达到高内聚低耦合的原则，正交四原则是指导我们在代码中如何真正去践行，具有很好的指导意义，最后设计模式是应用这些原则中出现的通用问题解，我们可以用这些模式解决重复性问题。
