5.5条件逻辑的复杂

如果条件语句很容易理解，且只包含少量代码，那么条件语句是没有怀味道的。通常情况下，对同一组判断条件，随着项目的不断迭代，会增加越来越多的逻辑。

同一组条件逻辑或Switch语句在项目代码里屡见不鲜。

 

5.5.1 分解条件表达式
通过提炼代码，把一段 「复杂的条件逻辑」 分解成多个独立的函数，这样就能更加清楚地表达自己的意图。

if (date.before (SUMMER_START) || date.after(SUMMER_END)) {
     charge = quantity * _winterRate + _winterServiceCharge;
} else {
     charge = quantity * _summerRate;
}
 


// 分解如下

if (notSummer(date)) {
      charge = winterCharge(quantity);
}else {
     charge = summerCharge (quantity);
}
… … 
 

5.5.2 合并条件表达式
当一系列的条件分支都得到相同的结果，可将这些条件分支合为一个条件表达式，并提炼成一个独立的函数。

// 重构前

double DisabilityAmount(){

    if (m_seniority < 2) {

        return 0;

    }

    if (m_monthsDisabled > 12) {

        return 0;

    }

    if (m_isPartTime) {

        return 0;

    }

    // ...

}

// 重构后

double DisabilityAmount(){

    if (IsNotEligibleForDisability()) {

        return 0;

    }

    // ...

}

bool IsNotEligibleForDisability(){

    return m_seniority < 2 || m_monthsDisabled > 12 || m_isPartTime;

}

 

5.5.3 移除控制标记
在一系列条件表达式中，常存在一个用于判断何时停止条件检查的控制标志。可通过break/continue/return来替换掉控制标志，提升代码可读性。

// 重构前

void CheckSecurity(vector<string>& peoples) {

    bool isCheck = false;

    for (auto& people : peoples) {

        if (!isCheck) {

            if (people == "Don") {

                SendAlert();

                isCheck = true;

            }

            if (people == "John") {

                SendAlert();

                isCheck = true;

            }

        }

    }

}

// 重构后

void CheckSecurity(vector<string>& peoples) {

    for (auto& people : peoples) {

        if (people == "Don") {

            SendAlert();

            break;

        }

        if (people == "John") {

            SendAlert();

            break;

        }

    }

}

5.5.4 卫语句取代嵌套条件
嵌套的if/else语句式造成代码可读性差，让人难以看清正常的执行路径。可通过使用卫语句(Guard Clauses)表现所有特殊情况(常见就是对条件进行反转)来消除嵌套的条件表达式，提高代码可读性。

// 重构前

double GetAdjustedCapital() {

    double result = 0.0;

    if (m_capital > 0.0) {

        if (m_intRate > 0.0 && m_duration > 0.0) {

            result = (m_income / m_duration) * ADJ_FACTOR;

        }

    }

    return result;

}

// 重构后

double GetAdjustedCapital() {

    if (m_capital <= 0.0) {

        return 0.0;

    }

    if (m_intRate <= 0.0 || m_duration <= 0.0) {

        return 0.0;

    }

    return (m_income / m_duration) * ADJ_FACTOR;

}

 

5.5.5 多态取代条件表达式
如果有个条件表达式，根据类型码的不同而选择不同的行为。可通过多态替换条件表达式，将表达式的每一个分支放进一个子类内的覆写函数中，将原函数声明为抽象函数。

 

5.6迷惑的临时字段

一个类包含属性和方法，属性都是该类相关的。而临时向类中添加的字段，虽然临时有关联性，但是单独来看这个类中的属性时，却会让人费解。有些接口的返回值也是类似原因导致的结果，每次为了方便，向类中直接添加一些临时属性，满足了当时的需要，但后续再使用时却并不能区分哪些属性必须，哪些不必须，以及哪些被添加的字段的上下文分别是什么。

 

5.6.1 处理迷惑的字段
在一个类中，某个字段只在特定的情况下才有用，其余情况下容易令人迷惑。

l  原因是随意向类添加字段，解决方法就是将这个临时字段移走，可以为这个字段找到一个合适的类来存放，也可以使用提炼类将这个字段添加到一个新类中，然后将该字段的相关的逻辑移动到该类中，并确定该类的职责

l  可以将临时字段作为参数进行传递，但是为了避免过长参数的出现，可选择将临时字段提炼到一个新的类中

l  对于一个字段，如果在其所驻类之外的另一个类中有更多函数使用了它，就可以将该字段搬移到另一个对象中

 

5.6.2 临时变量的赋值
如果有某个临时变量被赋值超过一次，则可以使用Split Temporary Variable进行重构，针对每一次赋值，创造一个独立、对应的临时变量。

// 重构前

double temp = 2 * (m_height + m_width);

cout << temp << endl;

temp = m_height * m_width;

cout<< temp << endl;

// 重构后

double perimeter = 2 * (m_height + m_width);

cout << perimeter << endl;

double area = m_height * m_width;

cout<< area << endl;

 

5.7不恰当的暴露

当不应该客户代码看到的方法或类，却对客户可见时，就会存在这种坏味道。客户了解到不太重要或只有间接重要性的代码，这会增加代码的复杂度

 

// 不想知道哪些子类

struct AnnotationBase {

    MessageBase(…);

}

struct PenAnnotation : AnnotationBase {

    PenAnnotation (…) : AnnotationBase (…) {}

}

struct DocAnnotation: AnnotationBase {

    DocAnnotation (…) : AnnotationBase (…) {}

}

std::vector<std::shared_ptr< AnnotationBase >>

createAnnotations() {

    std::vector<std::shared_ptr<AnnotationBase>> list;

    list.emplace_back(new DocAnnotation(“localId”, INTEGER);

    list.emplace_back(new DocAnnotation(“remoteId”, Date);

    // ……

}

 

5.8数据泥团

DataClumps指多个类中有着相同字段,或多个函数的签名中有着相同的字段。

 

重构方式： 提炼类 或 引入参数对象

引入参数对象重构

代码中可能有一组参数总是一起被传递到好几个函数中，这样的一组参数就是所谓的数据泥团。常见的有指代一个时间范围的startTime/endTime，可以通过引入参数对象手法，以一个对象取代这些参数。[示例]

// 重构前

class Account {

public:

    double GetFlowBetween(Date& startTime, Date& endTime) {

        double result = 0.0;

        for (auto& entry : m_entries) {

            if (entry.GetDate() == startTime || entry.GetDate() == endTime ||

                (entry.GetDate().After(startTime) && entry.GetDate().Before(endTime)) {

                result += entry.GetValue();

            }

        }

        return result;

    }

}

// 重构后

class Account {

public:

    double GetFlowBetween(DateRange& dateRange) {

        double result = 0.0;

        for (auto& entry : m_entries) {

            if (dateRange.Includes(entry.GetDate())) {

                result += entry.GetValue();

            }

        }

        return result;

    }

}

class DateRange {

public:

    bool Includes(Date& date) {

        return date == m_startTime || date == m_endTime ||

                (date.After(m_startTime) && date.Before(m_endTime));

    }

private:

    Date m_startTime;

    Date m_endTime;

}

一组参数总是一起被传递到好几个函数中，这样的一组参数就是所谓的Data Clumps。重构的方式就是引入参数对象，以一个对象取代这些参数。

 

5.9基本类型偏执

基本类型包括整数、字符串、双整型、数组和其他低层次的语言要素，都具备一般性，因此很多人都要使用它们。在许多情况下，用类抽象地封装基本类型是更自然的方式，创建类之后，会发现很多其他代码都应属于这个类。

 

基本类型偏执总体表现为以基本类型表示一些具有业务性质的概念

l  基本类型都是独立的出现

l  几个基本类型总是一起出现（可能出现在函数参数列表中）

 

5.9.1 基本类型重构方式
一个类中如果有很多基本类型的成员，通常可以考虑将不同的基本类型分散组装成对象，就像Hibernate中的组合映射那样，将一个类的对象嵌入到另一个类中作为其成员而不是只写一个类，里面有很多基本数据类型的成员。

 

更好的方法是在设计阶段对通用语言进行领域建模，并赋予对象业务行为函数，这样可以使复杂的系统更加清晰。

 

5.9.2 以对象取代数据值
软件开发初期，往往会以简单基本类型来表示某一概念，随着开发的迭代，这些概念不再是简单的基本类型就能表示的，这时就需要以对象取代数据值进行重构，封装一个新的对象来取代原有的基本类型数据值。譬如，刚开始使用一个字符串来表示“电话号码”的概念，但随后就会发现，电话号码需要“格式化”、“抽取区号”之类的特殊行为，这些就需要将“电话号码”封装成一个对象了。

在这里插入图片描述

 

5.10            分支语句

代码中出现switch表达式，常用于根据类型码来选择不同的行为，或只是单一函数中有些选择事例(可能选择条件之一是NULL)。

switch语句(或if… elseif … elseif … else 结构的等效语句)本身没有问题。只有在使用这种语句会使设计过度地复杂或僵硬时，才会成为问题。带有坏味道的switch语句通常指那些造成重复代码的switch语句，如果要为它添加一个新的case语句，就必须找到所有并修改它们。

 

示例：根据某个状态来判断执行哪个动作。

public Order nextStep(...) {

     if (state == 1) {

          // do something

     } else if (state == 2) {

          // do something

     } else if (state == 3) {

          // do something

     } else {

          // do something

     }

}

多数使用这种方式添加代码，并不意味着这是一种好的代码。这样的实现方式很容易造成长函数，且每次修改的位置要非常精准，需要在多个条件中逐个遍历找到最终需要的那个，再修改，可读性上也差。

 

5.10.1 处理switch坏味道
1)   如果switch语句是某个方法的一部分，那么不妨将其先提炼出一个单独的方法，缩小上下文范围。

2)   观察多个条件中的动作的关联关系，是否符合多态，如果是，将符合多态的几个条件创建对应的类，并移动函数到新创建的类中。

3)   使用状态模式、枚举等多种实现手段消除其中的switch语句

4)   其它方式 …

 

总之，一旦打算通过叠加新的switch case来添加新逻辑，那么就应关注一下代码设计，因为这种操作很有可能会为后续的代码在挖坑。同时理解清楚哪些switch语句是具有坏味道的语句。

 

5.11            组合爆炸

传统情况下给类添加职责使用的是继承，如果添加的职责很多，需要为每种情况(职责的排列组合)都定义一个固定类。假如要为一个原始类添加5个职责，则会出现5的阶乘种情况，不仅带来类组合爆炸的繁琐，运行时对职责的修改是任意的，使得编译时确定的类又要在运行时频繁改变。而直接往对象中添加职责则使结构可灵活多变，同样的情况，只需额外增加5个修饰类就可解决类爆炸及运行时改变的情况。

 

平行继承体系, 每当为某个类增加一个子类，也必须为另一个类相应增加一个子类；修改其中一个结构中的类要相应的修改另一个结构中的类，则可考虑让一个体系中的实体引用（桥接）另一个体系中的实体。

示例： 向redis、mq队列里面 push 数据。

classboom00.png-35.7kB

发送消息，可分为 3 个步骤：

1)   不同的消息(短信、微信)组装各自的数据格式和内容;

2)   消息可以使用不同的方式(redis 、 mq)推送到队列里;

3)   使用send方法，先从步骤 1 获取数据，再利用步骤 2 的方法 push 到相应的队列

 

假设需求要新增 Email 消息类型（类爆炸）

此时，再增加 Mysql 队列的发送方式

假设再新增一种消息类型和发送方式，又会新增多少个类？

l  针对接口编程；  

l  优先使用对象组合，而不是类继承（耦合性）；  

l  找到并封装变化的点。

 

5.11.1 重构之Bridge模式
将抽象部分与它的实现部分分离，可以独立地变化，要善用组合/委托；移动方法，移动字段。变化点有 2 个：一个是消息类型，一个是发送方式。

ok1.png-27kB

 

5.12            怪异解决方案

在同一系统中应该始终用一种方式解决一种问题。使用不同的方式解决同一问题，就称为怪异的或不一致的解决方案。这也是一种重复(代码、功能性)。

简单示例：

const unsigned int max_wait_milliseconds = 1000;

#define MAX_WAIT_MILLSECONDS ((unsigned int)1000)

unsigned int getMaxWaitMillseconds() _

   return 1000;

}

//重构后

const unsigned int max_wait_milliseconds = 1000;

#define MAX_WAIT_MILLSECONDS ((unsigned int)1000)

unsigned int getMaxWaitMillseconds() _

   return max_wait_milliseconds;

}

 

5.13            解决方案蔓延

面对如果很多类中都有用来完成某些职责的代码、数据；面对当添加或更新系统特性时，需要对许多不同的代码段进行修改；没有做到局部化影响等等，观察发现到这些，就存在解决方案蔓延的坏味道。

 

5.13.1 发散式变化
Divergent Change这种坏味道会导致新功能难以加入，简单的说如果程序中的可变因素散落在代码的各个角落中，那么代码的维护将是一场恶梦。重构的方法是找到特定原因造成的所有变化，然后将它们抽取到另一个类中。设计模式中的桥接模式就是为了解决这一问题而提供的解决方案。

 

重构方法：提炼类

根据单一职责原则，将类的一些函数和字段进行抽离，封装成一个新的类。

 

5.13.2 散弹式修改
Shotgun Surgery说的是某种变化会引发多个细节的修改。可通过搬移函数、搬移字段来重构。譬如，对于一个字段，如果在其所驻类之外的另一个类中有更多函数使用了它，就可以将该字段搬移到另一个对象中。搬移之后需要在新的类中提供该字段的访问函数，否则原对象就无法访问到该字段。

 

5.13.3 蔓延的对象创建
void calcShapePerimeter(const string& shape, double len) {

        unique_ptr<Shape> *shapePtr;

        if (shape == “square”) {

                 Shape = new Square(len);

        } else (shape == “circle”) {

                 Shape = new Circle(len);

        }

        cout<< “Area is “ << shape ->getPerimeter() << endl;

}

void calcShapeArea(const string& shape, double len) {

        unique_ptr<Shape> *shapePtr;

        if (shape == “square”) {

                 Shape = new Square(len);

        } else (shape == “circle”) {

                 Shape = new Circle(len);

        }

        cout<< “Area is “ << shape ->getArea() << endl;

}

 

5.14            过多的代码注释

注释本身并不是一种坏味道。如果一段代码有着长长的注释，很可能是因为代码很糟糕，甚至误导了代码要表达的意图。

 

5.14.1 过多的注释是一种坏味道
l  如果想通过注释来表达代码的意思，那么代码修改了注释也需同步进行修改，如果代码修改了但注释没有修正，就有可能导致误导

l  另外，不使用的代码通过注释掉来表示其弃用，后续代码的阅读者会经常受到断断续续的注释掉的代码影响，降低读、改代码的效率

l  多余的/误导性/日志式/废话/类的归属的注释 …

 

5.14.2 如何解决代码的过多注释
l  删除被注释掉不再使用的代码

l  如果某段代码没办法轻松的解释清楚，可提炼方法且使用提炼方法名来表达意图

l  删除多余的注释，误导性注释，如有必要可以将方法重命名，解释意图

l  用来说明变量意思的注释删除掉，对变量进行重命名，如果这个变量并不是必须的可以选择将变量进行Inline Temp

 

注释不是用来补救劣质代码的，事实上如果去除了代码中的所有坏味道，当劣质代码都被移除的时候，注释已变得多余。

6.   开发者测试

重构代码最重要的一个先验条件是自动化测试。重构之前，先保证一组可靠的测试用例，这不仅有助于Bug检测，其中也有一种以终为始的思想在里面。实际上，可以通过编写测试用例，更加清楚最终的函数应该长什么样子，提供什么样的服务。有助于保持较低缺陷数,大胆地进行重构,从而得到更简单、更优秀的代码。

 

重构是解决“过度设计”的过渡方案，而敢去重构的基础是单元测试覆盖率。此外，高单元测试覆盖率特别是高分支覆盖率又能反过来鼓励进行更好设计(细分功能单元便于编写测试，消除重复代码避免重复测试等)，形成良性循环。

 

Test-Driven Development
TDD的一个核心思想是小步增量，持续重构。包含两个状态：

l  状态A：用test case描绘需求，并使用最简方式满足这个test case，不能为任何test case之外的需求做任何设计，通过之后进入状态B

l  状态B：重构代码，让现有的代码在尽量保持简单性的同时足够优雅清晰

 

整个TDD的过程就是在这两个状态间不断转换的过程。在状态A增加功能，在状态B优化设计。这种思维方式走的稍微极端一点,它直接排斥任何对未来的设计，转而以优雅简洁的设计和test case来为未来需求的重构降低成本。可以说严格遵循TDD的设计必然在过度设计和设计不足方面都不会有太大问题。

 

编写一个测试 à 编写代码通过测试 à 提炼、合并、消除歧义 à ……

 

7.   重构规则谈

上个章节介绍了代码中常见的多种代码坏味道，每种坏味道通过几步重构即可解决。面对这些应该避免延迟解决，随时保持代码的整洁。

 

针对大规模的重构项目，在前期控制参与人员，在小范围内实现核心功能，并通过重构改良设计，然后再增加人员进行全面开发，也会是一个很好的实践。

 

7.1重构的时机

在实践中一般都是从某一代码坏味道着手重构。

7.1.1 事不过三，三则重构
三次法则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该重构。

 

7.1.2 添加新功能时
在动手添加新功能之前，常会发现：如果对代码结构做一点微调，工作会容易得多。也许已经有个函数提供了需要的大部分功能，但有几个字面量的值与需要略有冲突。如果不做重构，可能会把整个函数复制过来，这就会导致重复代码。

 

7.1.3 修补错误时重构
在寻找Bug问题根因时可能会发现：如果把3段一模一样且会导致错误的代码合并到一处，问题修复起来会容易得多。或者，把某些更新数据的逻辑与查询分开，会更易避免造成错误的逻辑纠缠。用重构改善，在同样场合再次出现同样Bug的概率也会降低。

 

7.1.4 复审代码时重构
在CodeView时加入重构，取决于复审的形式。复审者独自检视代码，代码的作者不在旁边，此时重构的效果并不好。如果代码的作者在旁边，能提供关于代码的上下文信息，并且充分认同复审者进行修改的意图，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审。

 

7.1.5 帮助理解的重构
一旦需要思考“这段代码到底在做什么”，能不能重构这段代码，令其一目了然？可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了，这些都是重构的机会。

 

先在一些小细节上使用重构来帮助理解，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。当代码变得更清晰一些时，常会看见之前看不见的设计问题。如果不做前面的重构，可能永远都看不见这些设计问题。有的人认为这些重构只是毫无意义地把玩代码，而没有意识到，缺少了这些细微的整理，也许就无法看到隐藏在一片混乱背后的机遇。

 

7.1.6 计划和见机行事的重构
上面的重构方式都是见机行事的，不管是要添加功能还是修复BUG，重构对当下的任务有帮助，且让后续的工作更轻松。重构不是与编程割裂的行为，大部分重构应该是不起眼的、见机行事的，在做其他事的过程中自然发生。

 

如果团队过去忽视了重构，那么常常会需要专门花一些时间来优化代码库，以便更易添加新功能。在重构上花一个星期的时间，会在未来几个月里发挥价值。有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来解决。

 

7.2重构的优先级

实践中一般都是从某一代码坏味道着手重构，但现实中可能有一堆的代码问题等待解决，而时间、成本、人力是有限的，所以需要从最有价值，最没有争议的部分开始重构.

 

简单设计四原则的重要程度是依次降低的，对于四条原则的判定从上往下也是逐渐主观化，所以选择重构的代码的优先级顺序也是按照它们破坏简单四原则的顺序依次降低! 如果一坨代码存在很多重复，另外一坨代码不易理解，那么优先选择去解决重复代码的问题，因为按照简单四原则消除重复更重要，也更容易被客观评价.

 

7.3重构的手法

存在一系列代码变换的操作，应用这些操作之后，在相同的输入条件下，软件的输出不会发生变化. 满足上述要求的代码操作称之为代码等价变换操作。

 

代码等价变换操作(例如: 重命名变量，为函数增加一个参数，删除一个不被引用的类…). 按照一定设计好的顺序组合上述低层次的代码等价变换操作，可以完成一次安全的代码重构，保证代码重构前后的行为保持要求。

 

http://img.mp.itc.cn/upload/20160926/ef9fbed3db7746a187810a7c6b12eef1_th.jpeg

重构中使用的是安全小步的代码等价变换手法，为什么还需测试? 首先是因为是人总会犯错! 另外由于编程语言的复杂性导致所谓的等价变换是受上下文约束的，例如在C++中为一个存在继承关系的类的成员方法重命名，有可能导致新的方法名和它某一父类中有默认实现的虚方法重名，而即使编译器也不能发现该错误.

 

7.4什么时候不应重构

重构并不是必要，当然也有一些不那么需要重构的情况：

.不需要修改，那些丑陋的代码能隐藏在一个 API 之下。只有当需要理解其工作原理时，对其进行重构才会有价值；

ⷼ重写比重构容易，这可能就需要良好的判断力和丰富的经验才能够进行抉择。如果“既有代码实在太混乱，重构它还不如重新写一个简单”时就应该重写，而不是重构。

 

7.5长期的重构

大多数重构可以在几分钟、最多几小时内完成。但有一些大型的重构可能要花上几个星期，例如要替换一个正在使用的库，或者将整块代码抽取到一个组件中并共享给另一支团队使用，再或者要处理一大堆混乱的依赖关系等等。

 

可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略。每当有人靠近“重构区”的代码，就把它朝想要改进的方向推动一点。这个策略的好处在于，重构不会破坏代码—每次小改动之后，整个系统仍然照常工作。例如，如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口，一旦调用方已完全改为使用这层抽象，替换下面的库就会容易得多。

 

工程开发过程，重构可随时随地进行。尤其对于采用演进式设计方法论，重构和代码开发是紧密结合难以分割，甚至很多时候只有依托重构才能完成代码的开发。

 

 

最 后

 

重构永远是开发人员无法回避的话题，当软件在编写的那一刻起，重构就不可避免。做一个系统，为什么要费劲地不断抽象，竭尽全力让代码能够被重用，说白了就是让我们今日所付出的时间，让未来的我们能够更轻松地工作而已。最优的设计应该把最可能发生的需求变动和人员变动考虑在内：对需求变动做到代码不重复，高聚合，低耦合；对人员变动则至少需要做到代码易读，符合思维习惯。

 

重构既是脑力活，也是体力活。特别是在软件中的“代码坏味道”积累到一定量时，就需要花费大量的时间和精力才能完成对代码的重构。因此，需要加强对“代码坏味道”的嗅觉，在发现“代码坏味道”时及时地去重构，通过不断的微重构来阻止代码架构的腐化，从而避免走上代码重写的艰难之路。

 

重构不是包治百病的灵丹妙药，也绝对不是所谓的“银弹”。重构只是一种工具，能够帮助你始终良好的控制代码而已。重构也非一蹴而就的事，需要长期的实践和经验才能完成得很好。

重构强调的是 Be Better ！

 

 

附：相关博文

【软件系统设计之专题一】 - 可信构架之道

http://3ms.huawei.com/km/blogs/details/8777275?l=zh-cn

【软件系统设计之专题二】 - 高并发之并行模式

http://3ms.huawei.com/km/blogs/details/8847021?l=zh-cn

【软件系统设计之专题三】- 分布式一致与共识

http://3ms.huawei.com/km/blogs/details/8906573?l=zh-cn

【软件系统设计之专题四】 - 调度策略及算法

http://3ms.huawei.com/km/blogs/details/9088879?l=zh-cn

SOLID原则精解之开放封闭原则 OCP

http://3ms.huawei.com/km/blogs/details/8392135?l=zh-cn

SOLID原则精解之接口隔离原则 ISP

http://3ms.huawei.com/km/blogs/details/8472817?l=zh-cn
