5.5条件逻辑的复杂

如果条件语句很容易理解，且只包含少量代码，那么条件语句是没有怀味道的。通常情况下，对同一组判断条件，随着项目的不断迭代，会增加越来越多的逻辑。

同一组条件逻辑或Switch语句在项目代码里屡见不鲜。

 

5.5.1 分解条件表达式
通过提炼代码，把一段 「复杂的条件逻辑」 分解成多个独立的函数，这样就能更加清楚地表达自己的意图。

if (date.before (SUMMER_START) || date.after(SUMMER_END)) {
     charge = quantity * _winterRate + _winterServiceCharge;
} else {
     charge = quantity * _summerRate;
}
 


// 分解如下

if (notSummer(date)) {
      charge = winterCharge(quantity);
}else {
     charge = summerCharge (quantity);
}
… … 
 

5.5.2 合并条件表达式
当一系列的条件分支都得到相同的结果，可将这些条件分支合为一个条件表达式，并提炼成一个独立的函数。

// 重构前

double DisabilityAmount(){

    if (m_seniority < 2) {

        return 0;

    }

    if (m_monthsDisabled > 12) {

        return 0;

    }

    if (m_isPartTime) {

        return 0;

    }

    // ...

}

// 重构后

double DisabilityAmount(){

    if (IsNotEligibleForDisability()) {

        return 0;

    }

    // ...

}

bool IsNotEligibleForDisability(){

    return m_seniority < 2 || m_monthsDisabled > 12 || m_isPartTime;

}

 

5.5.3 移除控制标记
在一系列条件表达式中，常存在一个用于判断何时停止条件检查的控制标志。可通过break/continue/return来替换掉控制标志，提升代码可读性。

// 重构前

void CheckSecurity(vector<string>& peoples) {

    bool isCheck = false;

    for (auto& people : peoples) {

        if (!isCheck) {

            if (people == "Don") {

                SendAlert();

                isCheck = true;

            }

            if (people == "John") {

                SendAlert();

                isCheck = true;

            }

        }

    }

}

// 重构后

void CheckSecurity(vector<string>& peoples) {

    for (auto& people : peoples) {

        if (people == "Don") {

            SendAlert();

            break;

        }

        if (people == "John") {

            SendAlert();

            break;

        }

    }

}

5.5.4 卫语句取代嵌套条件
嵌套的if/else语句式造成代码可读性差，让人难以看清正常的执行路径。可通过使用卫语句(Guard Clauses)表现所有特殊情况(常见就是对条件进行反转)来消除嵌套的条件表达式，提高代码可读性。

// 重构前

double GetAdjustedCapital() {

    double result = 0.0;

    if (m_capital > 0.0) {

        if (m_intRate > 0.0 && m_duration > 0.0) {

            result = (m_income / m_duration) * ADJ_FACTOR;

        }

    }

    return result;

}

// 重构后

double GetAdjustedCapital() {

    if (m_capital <= 0.0) {

        return 0.0;

    }

    if (m_intRate <= 0.0 || m_duration <= 0.0) {

        return 0.0;

    }

    return (m_income / m_duration) * ADJ_FACTOR;

}

 

5.5.5 多态取代条件表达式
如果有个条件表达式，根据类型码的不同而选择不同的行为。可通过多态替换条件表达式，将表达式的每一个分支放进一个子类内的覆写函数中，将原函数声明为抽象函数。

 

5.6迷惑的临时字段

一个类包含属性和方法，属性都是该类相关的。而临时向类中添加的字段，虽然临时有关联性，但是单独来看这个类中的属性时，却会让人费解。有些接口的返回值也是类似原因导致的结果，每次为了方便，向类中直接添加一些临时属性，满足了当时的需要，但后续再使用时却并不能区分哪些属性必须，哪些不必须，以及哪些被添加的字段的上下文分别是什么。

 

5.6.1 处理迷惑的字段
在一个类中，某个字段只在特定的情况下才有用，其余情况下容易令人迷惑。

l  原因是随意向类添加字段，解决方法就是将这个临时字段移走，可以为这个字段找到一个合适的类来存放，也可以使用提炼类将这个字段添加到一个新类中，然后将该字段的相关的逻辑移动到该类中，并确定该类的职责

l  可以将临时字段作为参数进行传递，但是为了避免过长参数的出现，可选择将临时字段提炼到一个新的类中

l  对于一个字段，如果在其所驻类之外的另一个类中有更多函数使用了它，就可以将该字段搬移到另一个对象中

 

5.6.2 临时变量的赋值
如果有某个临时变量被赋值超过一次，则可以使用Split Temporary Variable进行重构，针对每一次赋值，创造一个独立、对应的临时变量。

// 重构前

double temp = 2 * (m_height + m_width);

cout << temp << endl;

temp = m_height * m_width;

cout<< temp << endl;

// 重构后

double perimeter = 2 * (m_height + m_width);

cout << perimeter << endl;

double area = m_height * m_width;

cout<< area << endl;

 

5.7不恰当的暴露

当不应该客户代码看到的方法或类，却对客户可见时，就会存在这种坏味道。客户了解到不太重要或只有间接重要性的代码，这会增加代码的复杂度

 

// 不想知道哪些子类

struct AnnotationBase {

    MessageBase(…);

}

struct PenAnnotation : AnnotationBase {

    PenAnnotation (…) : AnnotationBase (…) {}

}

struct DocAnnotation: AnnotationBase {

    DocAnnotation (…) : AnnotationBase (…) {}

}

std::vector<std::shared_ptr< AnnotationBase >>

createAnnotations() {

    std::vector<std::shared_ptr<AnnotationBase>> list;

    list.emplace_back(new DocAnnotation(“localId”, INTEGER);

    list.emplace_back(new DocAnnotation(“remoteId”, Date);

    // ……

}

 

5.8数据泥团

DataClumps指多个类中有着相同字段,或多个函数的签名中有着相同的字段。

 

重构方式： 提炼类 或 引入参数对象

引入参数对象重构

代码中可能有一组参数总是一起被传递到好几个函数中，这样的一组参数就是所谓的数据泥团。常见的有指代一个时间范围的startTime/endTime，可以通过引入参数对象手法，以一个对象取代这些参数。[示例]

// 重构前

class Account {

public:

    double GetFlowBetween(Date& startTime, Date& endTime) {

        double result = 0.0;

        for (auto& entry : m_entries) {

            if (entry.GetDate() == startTime || entry.GetDate() == endTime ||

                (entry.GetDate().After(startTime) && entry.GetDate().Before(endTime)) {

                result += entry.GetValue();

            }

        }

        return result;

    }

}

// 重构后

class Account {

public:

    double GetFlowBetween(DateRange& dateRange) {

        double result = 0.0;

        for (auto& entry : m_entries) {

            if (dateRange.Includes(entry.GetDate())) {

                result += entry.GetValue();

            }

        }

        return result;

    }

}

class DateRange {

public:

    bool Includes(Date& date) {

        return date == m_startTime || date == m_endTime ||

                (date.After(m_startTime) && date.Before(m_endTime));

    }

private:

    Date m_startTime;

    Date m_endTime;

}

一组参数总是一起被传递到好几个函数中，这样的一组参数就是所谓的Data Clumps。重构的方式就是引入参数对象，以一个对象取代这些参数。

 

5.9基本类型偏执

基本类型包括整数、字符串、双整型、数组和其他低层次的语言要素，都具备一般性，因此很多人都要使用它们。在许多情况下，用类抽象地封装基本类型是更自然的方式，创建类之后，会发现很多其他代码都应属于这个类。

 

基本类型偏执总体表现为以基本类型表示一些具有业务性质的概念

l  基本类型都是独立的出现

l  几个基本类型总是一起出现（可能出现在函数参数列表中）

 

5.9.1 基本类型重构方式
一个类中如果有很多基本类型的成员，通常可以考虑将不同的基本类型分散组装成对象，就像Hibernate中的组合映射那样，将一个类的对象嵌入到另一个类中作为其成员而不是只写一个类，里面有很多基本数据类型的成员。

 

更好的方法是在设计阶段对通用语言进行领域建模，并赋予对象业务行为函数，这样可以使复杂的系统更加清晰。

 

5.9.2 以对象取代数据值
软件开发初期，往往会以简单基本类型来表示某一概念，随着开发的迭代，这些概念不再是简单的基本类型就能表示的，这时就需要以对象取代数据值进行重构，封装一个新的对象来取代原有的基本类型数据值。譬如，刚开始使用一个字符串来表示“电话号码”的概念，但随后就会发现，电话号码需要“格式化”、“抽取区号”之类的特殊行为，这些就需要将“电话号码”封装成一个对象了。

在这里插入图片描述

 

5.10            分支语句

代码中出现switch表达式，常用于根据类型码来选择不同的行为，或只是单一函数中有些选择事例(可能选择条件之一是NULL)。

switch语句(或if… elseif … elseif … else 结构的等效语句)本身没有问题。只有在使用这种语句会使设计过度地复杂或僵硬时，才会成为问题。带有坏味道的switch语句通常指那些造成重复代码的switch语句，如果要为它添加一个新的case语句，就必须找到所有并修改它们。

 

示例：根据某个状态来判断执行哪个动作。

public Order nextStep(...) {

     if (state == 1) {

          // do something

     } else if (state == 2) {

          // do something

     } else if (state == 3) {

          // do something

     } else {

          // do something

     }

}

多数使用这种方式添加代码，并不意味着这是一种好的代码。这样的实现方式很容易造成长函数，且每次修改的位置要非常精准，需要在多个条件中逐个遍历找到最终需要的那个，再修改，可读性上也差。

 

5.10.1 处理switch坏味道
1)   如果switch语句是某个方法的一部分，那么不妨将其先提炼出一个单独的方法，缩小上下文范围。

2)   观察多个条件中的动作的关联关系，是否符合多态，如果是，将符合多态的几个条件创建对应的类，并移动函数到新创建的类中。

3)   使用状态模式、枚举等多种实现手段消除其中的switch语句

4)   其它方式 …

 

总之，一旦打算通过叠加新的switch case来添加新逻辑，那么就应关注一下代码设计，因为这种操作很有可能会为后续的代码在挖坑。同时理解清楚哪些switch语句是具有坏味道的语句。

 

5.11            组合爆炸

传统情况下给类添加职责使用的是继承，如果添加的职责很多，需要为每种情况(职责的排列组合)都定义一个固定类。假如要为一个原始类添加5个职责，则会出现5的阶乘种情况，不仅带来类组合爆炸的繁琐，运行时对职责的修改是任意的，使得编译时确定的类又要在运行时频繁改变。而直接往对象中添加职责则使结构可灵活多变，同样的情况，只需额外增加5个修饰类就可解决类爆炸及运行时改变的情况。

 

平行继承体系, 每当为某个类增加一个子类，也必须为另一个类相应增加一个子类；修改其中一个结构中的类要相应的修改另一个结构中的类，则可考虑让一个体系中的实体引用（桥接）另一个体系中的实体。

示例： 向redis、mq队列里面 push 数据。

classboom00.png-35.7kB

发送消息，可分为 3 个步骤：

1)   不同的消息(短信、微信)组装各自的数据格式和内容;

2)   消息可以使用不同的方式(redis 、 mq)推送到队列里;

3)   使用send方法，先从步骤 1 获取数据，再利用步骤 2 的方法 push 到相应的队列

 

假设需求要新增 Email 消息类型（类爆炸）

此时，再增加 Mysql 队列的发送方式

假设再新增一种消息类型和发送方式，又会新增多少个类？

l  针对接口编程；  

l  优先使用对象组合，而不是类继承（耦合性）；  

l  找到并封装变化的点。

 

5.11.1 重构之Bridge模式
将抽象部分与它的实现部分分离，可以独立地变化，要善用组合/委托；移动方法，移动字段。变化点有 2 个：一个是消息类型，一个是发送方式。

ok1.png-27kB

 

5.12            怪异解决方案

在同一系统中应该始终用一种方式解决一种问题。使用不同的方式解决同一问题，就称为怪异的或不一致的解决方案。这也是一种重复(代码、功能性)。

简单示例：

const unsigned int max_wait_milliseconds = 1000;

#define MAX_WAIT_MILLSECONDS ((unsigned int)1000)

unsigned int getMaxWaitMillseconds() _

   return 1000;

}

//重构后

const unsigned int max_wait_milliseconds = 1000;

#define MAX_WAIT_MILLSECONDS ((unsigned int)1000)

unsigned int getMaxWaitMillseconds() _

   return max_wait_milliseconds;

}

 

5.13            解决方案蔓延

面对如果很多类中都有用来完成某些职责的代码、数据；面对当添加或更新系统特性时，需要对许多不同的代码段进行修改；没有做到局部化影响等等，观察发现到这些，就存在解决方案蔓延的坏味道。

 

5.13.1 发散式变化
Divergent Change这种坏味道会导致新功能难以加入，简单的说如果程序中的可变因素散落在代码的各个角落中，那么代码的维护将是一场恶梦。重构的方法是找到特定原因造成的所有变化，然后将它们抽取到另一个类中。设计模式中的桥接模式就是为了解决这一问题而提供的解决方案。

 

重构方法：提炼类

根据单一职责原则，将类的一些函数和字段进行抽离，封装成一个新的类。

 

5.13.2 散弹式修改
Shotgun Surgery说的是某种变化会引发多个细节的修改。可通过搬移函数、搬移字段来重构。譬如，对于一个字段，如果在其所驻类之外的另一个类中有更多函数使用了它，就可以将该字段搬移到另一个对象中。搬移之后需要在新的类中提供该字段的访问函数，否则原对象就无法访问到该字段。

 

5.13.3 蔓延的对象创建
void calcShapePerimeter(const string& shape, double len) {

        unique_ptr<Shape> *shapePtr;

        if (shape == “square”) {

                 Shape = new Square(len);

        } else (shape == “circle”) {

                 Shape = new Circle(len);

        }

        cout<< “Area is “ << shape ->getPerimeter() << endl;

}

void calcShapeArea(const string& shape, double len) {

        unique_ptr<Shape> *shapePtr;

        if (shape == “square”) {

                 Shape = new Square(len);

        } else (shape == “circle”) {

                 Shape = new Circle(len);

        }

        cout<< “Area is “ << shape ->getArea() << endl;

}

 

5.14            过多的代码注释

注释本身并不是一种坏味道。如果一段代码有着长长的注释，很可能是因为代码很糟糕，甚至误导了代码要表达的意图。

 

5.14.1 过多的注释是一种坏味道
l  如果想通过注释来表达代码的意思，那么代码修改了注释也需同步进行修改，如果代码修改了但注释没有修正，就有可能导致误导

l  另外，不使用的代码通过注释掉来表示其弃用，后续代码的阅读者会经常受到断断续续的注释掉的代码影响，降低读、改代码的效率

l  多余的/误导性/日志式/废话/类的归属的注释 …

 

5.14.2 如何解决代码的过多注释
l  删除被注释掉不再使用的代码

l  如果某段代码没办法轻松的解释清楚，可提炼方法且使用提炼方法名来表达意图

l  删除多余的注释，误导性注释，如有必要可以将方法重命名，解释意图

l  用来说明变量意思的注释删除掉，对变量进行重命名，如果这个变量并不是必须的可以选择将变量进行Inline Temp

 

注释不是用来补救劣质代码的，事实上如果去除了代码中的所有坏味道，当劣质代码都被移除的时候，注释已变得多余。
