http://3ms.huawei.com/km/blogs/details/5340167

一、总结者思考

在大规模团队软件开发活动中，代码的可维护性的重要程度，超过了对性能追求的重要性。可维护性直接与软件研发成本、上线周期相关联，与商业价值强相关。而软件性能等质量属性，大多数属于可以专项提升的。比如性能，虽然每行代码都有具有更好性能的写法，但是，如果为此而每句斟酌、甚至以代码的可读性为交换代价，那么就得不偿失了。性能的瓶颈，最终会聚集在整个软件中的某一模块、函数上。往往是只要性能瓶颈点被我们找出，并做了优化，则整体性能指标就能够大幅提升，并达到基线要求。我们在代码中通篇所做的每一行优化，都不如在瓶颈点所做的优化来得效果大。对瓶颈点的优化，可以放弃对可读性、可维护性的要求，毕竟，用局部代码变丑陋而换取软件整体性能达标，这是值得的。
简而言之，从软件工程的角度来看，软件可维护性是质量属性中最重要的；而代码的可读性，又是达成可维护性的最重要的支柱。
下面，我们就来看几个软件可读性的例子，以例子的方式，来表达此书的主要思想。

二、例子

1、命名

     对于代码中的变量、函数、类等的每一次命名，都要看做是为代码逻辑添加注释的机会，应该让命名承载更多的信息，而不应草草应付之。
     1) getPage(url)——>downloadPage(url) // download比get更具体地描述了怎样获得页面的方式，隐含指出此操作需要网络连接，是个耗时操作。而get不能体现这些信息。
     2) int size()——>int height(), int nodeNum(), memBytes()
         // size()所承载的信息太少，而推荐的几个方法，让人一目了然函数统计的目标对象是谁。
     3) int tmp = xyz();
         这里的tmp命名，没有为理解代码提供有力的贡献。它仅体现出这是一个临时的玩意儿，但并没有体现出这是个什么玩意儿。更好的命名，可以是tmpUser、tmpConnection等。
         当然，如果这个变量的作用域很短，那么就可以不要求命名中承载太多的信息，甚至仅仅是个占位符即可：
         {
              int t = lVal;
              lVal = rVal;
              rVal = t;
         }
     4) 一些约定俗成的名称
         表示首尾包含的范围：
         min …… max
         first …… last
         表示不包含尾的范围：
         begin …… end
         布尔成员变量的get函数：
         isXyz() // 是否是、hasXyz() //是否拥有
    5) 嵌套循环的计数器命名：
         for (int i = 0; i < BUF_LEN; ++i) {
              for (int j = 0; j < BUF_LEN; ++j) {
                  a[j] = b[i];
         上面的代码很容易写成a[i] = b[i]或者a[i] = b[j]这个样子，尤其是这段代码是从其它地方拷贝过来时，或者里层for语句块过于复杂，以致小小的i和j淹没在语句中的场景下。
         此时，如果用如下方式命名循环索引，则很容易识别出意料之外的错误：
         for (int i_outer = 0; i_outer < BUF_LEN; ++i_outer) {
              for (int i_inner = 0; i_inner < BUF_LEN; ++i_inner) {
                   a[i_inner] = b[i_outer];
     6) 我们定义方法，并不仅仅是出于抽取公共逻辑的需要，还可以起到凸现程序主逻辑、降低阅读理解成本的作用：如果一段逻辑，由几块晦涩难懂的子逻辑组成，那么不妨将这几段子逻辑分别定义成几个函数，并为它们起上明确表意的名字，则整体逻辑理解起来就会顺畅很多。
     7) 同理，变量的定义，也可以是为了突出逻辑：
         calculateCost(parseConfig())；
         这里，parseConfig()函数的命名并不好，看不出来到底是针对什么的config，因此，逻辑的理解在此处有一定的不连续性。通过定义如下"多余"的变量，则将缺失的信息链中的一环补齐了：
         String[] employeeList = parseConfig()；
         calculateCost(employeeList)；
     总结：每一次给包/名称空间、类/接口/结构、函数、变量命名，都要看做是提升代码可维护性的一次重要机会，不能草率为之。
 
2、布局

     1) 一定范围内(比如函数、成员变量声明等)的代码不应都粘在一起，相关性比较紧密的代码尽量放在一个段落中，则代码阅读起来更有层次感。
     2) 代码采取什么样的格式不是最重要的，重要的是一致性。自己和自己一致、自己和他人一致、今天和昨天一致，至少在一个项目中保持一致性。

 

3、注释

     1) 注释应描述作者的意图，而非描述代码动作过程。如下两段注释描述的是同一段代码，但是后者才有意义：
         a. 在循环中遍历x数组，用数组当前成员值作为参数调用y函数，将函数调用结果累加。
         b. 统计部门所有员工的工资总额。 
     2) 用词应紧凑，如下2个注释，后者更好一些。
         a. 通过对盛装部门所有员工的工资信息的数组的变量的遍历，从而计算出该部门的员工工资总和。
         b. 统计部门所有员工的工资总额。
     3) 无用的注释不如没有，否则容易激怒阅读者:)
         // 设置age成员变量的值
         void setAge(int age)
         {
               this.age = age;
         }
     4) 对于历史遗留的参数过多的函数的调用，可以采用嵌入注释的方式标注(如果语言本身不提供指明参数名称的方式调用的话)，则可以大幅提升可读性。
         someFunc(33, 2018, "@", "-", "$")；
         修改为：
         someFunc(33/*统计职级*/, 2018/*统计年份*/, "@"/*生成报告的起始字符*/, "-"/*生成报告的雇员名单连接字符*/, "$"/*生成报告的结尾字符*/,)；
         则阅读者就不用打开此函数的声明或者API文档，来一一对照理解这些参数的含义了。

4、简化控制语句

1) if/else语句的顺序
         a. 正向的放前面，负向的放后面。
         if (found) {
             ******
         }
         else {
              ……
         } 
         而非：
         if (!found) {
              ……
         }
         else {
              ******
         } 
         b. 简单的放前面，复杂的放后面。
         if (found) {
              ……
         }
         else if(hireDate < x && age < 60) {
              ……
         }
         2) 多条件分支时尽量用swich/case代替if/else。


5、其它

     1) 当想实现一个通用功能时，尽可能先想到使用现有类库，这会让你的代码量更少，并复用别人深思熟虑的成果(含可读性方面的考虑)。现有类库没有实现你所需要的功能，反而是小概率事件。比如，String.format()，apache commons中的StringUtilities等类库实现的功能，往往是一个开发者第一反应是跃跃欲试想自己实现的功能。
     2) 接口的函数及函数的参数不应定义的数量太多，一个接口，应该以简洁明了的面目呈现。


结束语

原书中讲述了提升代码可读性的很多方面，这里仅仅总结了一小部分。在这个总结中，笔者的意图是描述出代码可读性的重要性，而非怎样做到提升代码可读性。

《完》
