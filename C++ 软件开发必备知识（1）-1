http://3ms.huawei.com/km/blogs/details/10169787

Version:0.10, last modified: 2021/04/15

Author: scott.zhang

 

1.   C 和 C++

2.   继承：私有、保护与公有

3.   虚函数与纯虚函数

4.   深浅拷贝,拷贝构造

5.   单参构造，explicit

6.   析构函数,显式析构

7.   友元函数和友元类

8.   Return Value Optimization

9.   override,overload,final

10.  接口定义事项

11.  default和deleted

12.  嵌入类,限制与约束

13.  数据初始化

14.  引用，指针

15.  指针，nullptr

16.  unique_ptr,shared_ptr

17.  string, char*, string::c_str

18.  左值，右值

19.  std::move语义

20.  类型推导auto,decltype

21.  类型后置

22.  强制类型转换

23.  typdef,#define,using

24.  const, #define

25.  函数inline内联

26.  static的作用

27.  std::function对象包装

28.  Lambda, 闭包

29.  std::bind

30.  锁的机制及管理

31.  volatile

32.  std::thread线程

33.  struct,union,bitfield

34.  内存资源及管理

35.  new,placement new

36.  基于范围的循环

37.  插入迭代器之inserter

38.  STL标准模板库

39.  异常、表达式

40.  模板，全特化，偏特化

附：相关博文分享
 

 

1.   C 和 C++

 

a）C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，更加抽象，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。

b）C和C++动态管理内存的方法不一，C用malloc/free，C++除此之外还有new/delete

c）C++支持函数重载，C不支持函数重载

d）C++中有引用，C中不存在引用的概念

e）C++ 更加严格和安全，如 const 正确性、指针和枚举类型的自动转换

…. …. 



C++ 版本

版本号

描述

C++98

1.0

第一个 C++ 标准

C++03

1.0.1

修正98标准中的一些bug

C++11

2.0

全新的现代 C++ 标准

C++14

2.1

上一版本的小改进

C++17

2.5

改进版本

C++20

3.0

大版本，加入较多新特性

 

1)       C++编译与执行的四阶段

a）预处理：根据文件中的预处理指令来修改源文件的内容， 产生.ii文件

b）编译：编译成汇编代码，产生汇编文件(.s文件)

c）汇编：把汇编代码翻译成目标机器指令，产生目标文件(.o或.obj文件)

d）链接：链接目标代码生成可执行程序，产生可执行文件(.out或.exe文件)

 

2)       extern “C”
为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

 

注：

禁止在extern "C"中包含头文件，有可能会导致 extern "C" 嵌套，部分编译器对 extern "C" 嵌套层次有限制，嵌套层次太多会编译错误。

在C，C++混合编程的情况下，在extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。

 

3)       C++静态和动态绑定
a）对象的静态类型和动态类型

静态类型：对象在声明时采用的类型，在编译时确定

动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改

b）静态绑定和动态绑定

静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定

动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定

 

虚函数使用动态绑定，其他的静态绑定

 

4)       类的特殊成员函数
空类成员函数, 只有当实际使用这些函数的时候，编译器才会去定义它们

·         默认构造函数   

·         缺省析构函数

·         缺省拷贝构造函数

·         缺省拷贝赋值运算符

·         缺省取址运算符

·         缺省const取址运算符

 

构造，拷贝，移动和析构函数提供了对象的生命周期管理方法：

构造函数（constructor）： X()

拷贝构造函数（copy constructor）： X(const X&)

拷贝赋值操作符（copy assignment）： operator=(const X&)

移动构造函数（move constructor）： X(X&&)

移动赋值操作（move assignment）： operator=(X&&)  // C++11

析构函数（destructor）： ~X()           // C++11

 

注：

尽量使用C++的语言特性来编程，如使用string而不是 char* , 使 用vector而不是原生数组，使用namespace而不是static。

 

2.  继承：私有、保护与公有

class RichMan

{

public:

    RichMan();

    ~RichMan();

    int m_company;

private:

    int m_money;

    int m_car;

protected:

    int m_house;

};

·       m_company，自己，友元，子类，外部都可访问

·       m_money、m_car，自己，友元可访问，子类和外部不可访问

·       m_house，自己，友元可访问，子类也可访问，外部不可访问

 

公有继承：public成员保持不变，private成员不可见，protected成员也保持不变；

私有继承：public和protected变成了private；纯粹是一种实现技术，在软件“设计”层面没有意义，只及于软件实现层面。

保护继承：public变成了protected，protected保持不变。

 

多重继承
多重继承提供了一种更简单的组合来实现多种接口或者类的组装与复用。

可用于实现接口分离与多角色组合。

 

问题：

1. 菱形继承所带来的数据重复，及名字二义性。因此，引入virtual继承来解决这类问题;

2. 即便不是菱形继承，多个父类之间的名字也可能存在冲突，从而导致的二义性;

3. 如果子类需要扩展或改写多个父类的方法时，造成子类的职责不明，语义混乱;

4. 相对于委托，继承是一种白盒复用，即子类可以访问父类的protected成员, 会导致更强的耦合。由于耦合了多父类，相对于单根继承，这会产生更强的耦合关系。

 

3.   虚函数与纯虚函数

用于实现多态(polymorphism，编译器针对虚函数产生可在运行时确定被调用函数的代码)的机制，通过基类访问派生类定义的函数。虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。

 

虚函数借助于指针或者引用来达到多态的效果，虚函数的标志是“virtual”关键字,基类声明的虚函数，在派生类中也是虚函数，即使不再用virtual关键字。

 

1)   “动态联编” 
VTABLE实际是一个函数指针的数组，每个虚函数占用这个数组的一个slot。一个类只有一个VTABLE，不管它有多少个实例。派生类有自己的VTABLE，但派生类的VTABLE与基类的有相同的函数排列顺序，同名的虚函数被放在两个数组的相同位置。在创建类实例的时候，编译器还会在每个实例的内存布局中增加一个vptr字段，该字段指向本类的VTABLE。通过这些手段，编译器在看到一个虚函数调用的时候，就会将这个调用改写。

类的实例对象不包含虚函数表，只有虚指针；

 

一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了，不“虚”了。也就是说不能在构造函数和析构函数中让自己“多态”。

 

设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。从设计的角度讲，出现在基类中的虚函数是接口，出现在派生类中的虚函数是接口的具体实现。通过这样的方法，就可以将对象的行为抽象化。

 

2)  纯虚函数 virtual=0
在普通的虚函数后面加上" =0"这样就声明了一个pure virtual function. 纯虚函数的意思是：一个抽象类,不要实例化,纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，派生类都会有这个函数。

1)      当在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；

2)      避免一个类被实例化，且在编译时就被发现，那使用pure virtual funcion

3)      这个方法必须在派生类(derived class)中被实现；

 

3)      基类虚析构函数 
析构函数也可以是虚的，甚至是纯虚的.

class A {
public:
  virtual ~A()=0; // 纯虚析构函数
};

当一个类打算被用作其它类的基类时，它的析构函数必须是虚的，否则派生类的析构函数用不上，会造成资源的泄漏。

而纯虚的析构函数并没什么作用，通常只有在希望将一个类变成抽象类（不能实例化的类），而这个类又没有合适的函数可被纯虚化的时候，可以使用纯虚的析构函数来达到目的。

 

如析构函数不被声明成虚函数，编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样会造成派生类对象析构不完全。

 

4)      禁止使用缺省参数
避免虚函数重载时，因参数声明不一致带来的困惑和问题，所有虚函数均不允许声明缺省参数值。

示例：虚函数display缺省参数值text是由编译时刻决定的，而非运行时刻，没有达到多态的目的：

virtual void Display(const std::string& text  = "Sub!")    {

       std::cout << text << std::endl;    

}

 

注:

构造函数不能是虚的

禁止在构造函数和析构函数中调用虚函数(只有基类构造完成后，才会完成派生类的构造，从而导致未实现多态的行为), 同样的道理也适用于析构函数。

 

4.   深浅拷贝,拷贝构造

简单来说，如果一个类拥有资源，当这个类的对象发生复制过程时，如果资源重新分配就是深拷贝；反之没有重新分配资源，就是浅拷贝。

 

拷贝构造函数
生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的则是拷贝构造函数.

 

调用情形：

1）用类的一个对象去初始化另一个对象的时候

2）当函数参数是类的对象时，就是值传递的时候；如果是引用传递则不会调用

3）当函数的返回值是类的对象或者引用的时候；

 

代码示例：

#include <iostream>

#include <string>

 

using namespace std;

class A{

    public:

        A(int i){ data = i;}   //自定义构造

        A(A && a);             //拷贝构造

        int getdata(){return data;}

    private:

        int data;

};

A::A(A && a){  //拷贝构造函数

     data = a.data;

     cout <<"拷贝构造函数执行完毕"<<endl;

}

int getdata1(A a){   //参数是对象，值传递，调用拷贝构造

    return a.getdata();

}

int getdata2(A &a){   //参数是引用传递，不调用拷贝构造

    return a.getdata();

}

 

A getA1(){            //返回值是对象，会调用拷贝构造

    A a(0);

    return a;

}

A& getA2(){    //返回引用，调用拷贝构造，函数内是临时对象，离开就消失

    A a(0);

    return a;

}

 

int main(){

    A a1(1); 

    A b1(a1);           //用a1初始化b1，调用拷贝构造

    A c1=a1;            //用a1初始化c1，调用

 

    int i=getdata1(a1);  //函数形参是类的对象，调用拷贝构造

    int j=getdata2(a1);  //函数形参类型是引用，不调用

  

    A d1=getA1();        //调用拷贝构造

    A e1=getA2();        //调用

    return 0;

}

 

拷贝构造函数和赋值运算符重载有以下不同：

1） 拷贝构造函数生成新的类对象，而赋值运算符不能

2） 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

 

注：当类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。

 

5.   单参构造，explicit

1)    单参数构造函数
一个参数的构造函数(或除了第一个参数外其余参数都有缺省值的多参构造函数)，承担了两个角色。

l  用于构建单参数的类对象

l  隐含的类型转换操作符．

 

#include <iostream>

class Base

{

public :

    Base(const char data)  {

        std::cout <<"constructor..." <<std::endl;

        this->m_data = data;

    }

 

protected :

    char m_data;

};

int main(void)

{

    Base base1('a');        // 用于构建单参数的类对象

    Base base2 = 'b';       // 隐含的类型转换操作符

    return 0;

}

这种方法看起来很方便，但有时这并不是我们想要，由此可能引入一些其他问题。触发隐式转换，生成一个临时的对象。往往这种隐式转换是让人迷惑的，并且容易隐藏Bug，得到了一个不期望的类型转换

 

2)     避免隐式转换(explicit)
用来修饰类的构造函数，表明该构造函数是显式的，在某些情况下，要求类的使用者必须显示调用类的构造函数时就需要使用explicit，反之默认类型转换可能会造成无法预期的问题。声明为explicit的构造函数不能在隐式转换中使用，只能显示调用，去构造一个类对象。

explicit构造函数用来防止隐式转换。

class Test2

{

public:

    explicit Test2(int n)  {

        num=n;

    }//explicit(显式)构造函数

private:

    int num;

};

Test2 t2=12;//编译错误,不能隐式调用其构造函数

Test2 t2(12);//显式调用成功

 

explicit只针对单个参数的类构造函数, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了。

拷贝构造函数X(const X&)不要声明为explicit，如被声明为explicit，则这个类对象不能用于传参和函数返回值，但仍可以直接调用。

 

6.   析构函数,显式析构

C++的最基本惯用法，程序运行到对象作用域之外时，会隐式的调用析构函数，析构函数执行完成后，对象的资源就被释放。

析构函数定义方式为： ~类名(){...}

 

1)      析构函数没有参数。因没有参数，所以析构函数也不能像构造函数一样重载。因此一个类中不可能像构造函数那样，有多种析构函数。

2)      当类的对象离开其作用域时，析构函数被调用，用于释放对象资源并销毁资源。

3)      可显式的定义析构函数，也可以不定义。这一点和构造函数相同。如显式的定义了析构函数，可以在函数体中书写一些语句，用于显示对象在释放前的值等。

 

4)   如果类没有定义析构函数，那么只有类中含有成员对象（或者本类的基类）拥有析构函数的情况下，编译器才会合成一个出来，否则析构函数被视为不要，也就不需要合成。

 

5)   对于多重继承和虚继承而言，情况要有所不同.譬如，当从Point3d和Vertex（虚拟继承自Point）派生出Vertex3d时，如果不声明Vertex3d的析构函数，但仍然希望Vertex3d对象结束时，调用Vertex的析构函数，那么编译器此时必须合成一个Vertex3d的析构函数，该函数唯一的任务就是调用Vertex的析构函数，如果提供一个Vertex3d的析构函数，编译器会扩展之，在我们的代码之后调用Vertex的析构函数，该扩展与构造函数的扩展类似，但是顺序相反.

a. 析构函数本身被执行

b. 调用成员类对象的析构函数（如有），调用顺序使他们声明的相反顺序

c. 重置虚表指针

d. 调用非虚基类的析构（如有），调用顺序为声明的相反顺序

e. 调用虚基类的析构（如有），如果当前类是最尾端（most-derived）的类，那么虚基类用原来构造顺序的相反顺序析构

 

一个类对象生命结束于其析构函数调用开始执行之时，由于每一个基类析构函数都会被调用，所以子类实际上变成了一个完整的对象，例如：对于类d继承自c，c继承自b，b继承自a，当d对象析构时，会依次变成一个c对象，b对象，a对象，当在析构函数中调用成员函数时，对象的蜕变会因为虚表指针的重新设定（析构函数中，程序员所供应的代码执行之前）而受到影响。

 

1)    析构事项
A、只有真实存在的对象离开其作用域时才会调用析构函数，对象的引用，指向对象的指针离开其作用域时，不会调用析构函数。建议当对象离开其作用域后，让对象的引用，指向对象的指针失效，或者干脆就不再使用它。

B、使用new运算符创建的对象的资源，只有使用delete运算符删除指向它的指针时，才会调用它的析构函数，释放它的资源。这点要特别注意，当在类中显式定义析构函数时，函数体中通常就包含delete语句。

C、类中的静态成员属于类，不属于类的对象，它们的资源不会被析构函数释放。

 

通常情况下，我们不需要显式定义析构函数，除非我们需要它完成一些工作。如果一个类需要手动定义一个析构函数，那么通常情况下，这个类也需要手动定义复制构造函数和赋值运算符重载函数。

 

复制构造函数用于对象的复制，赋值运算符重载函数的功能和复制构造函数几乎一样。通常，将复制构造函数和赋值运算符重载函数绑定，定义了一个，另一个也必须出现。

 

析构函数、复制构造函数和赋值运算符重载函数，这三个函数是C++类的复制控制(copy-control)成员。复制控制，就是控制类的对象的复制。其中复制构造函数和赋值运算符重载函数是用来复制对象，析构函数是用来删除对象。

 

通常，使用复制构造函数或者赋值运算符重载函数创建一个对象时，会获得资源，有时必须显式定义析构函数才能释放这样的对象的资源。

 

2)   显式析构
析构函数的调用与构造函数的调用有明显不同：析构函数可以被显式调用，而构造函数不能。显式调用析构函数和调用类的其它成员函数没什么不同。当析构函数被显式调用时，只执行它的函数体，而不删除对象的资源。也就是说，当析构函数被显式调用时，它就是一个普通的成员函数，没有析构功能。

 

并没有destroy对象, 只有对象声明周期结束时即对象销毁了再次调用destructor会造成Undefined Behavior;

1.析构函数并不是销毁对象，只是释放构造函数在构造时初始化的资源（包括堆上分配等）

2.只有类对象被销毁后再次调用用析构函数才会引起Undefined Behavior。

 

显式定义析构函数多用于以下两种情况：

1、用于查看对象在销毁的前一刻保存的内容。有时候为了测试程序，会用到。

2、在类中用new运算符动态分配了内存，可以在析构函数中使用delete运算符释放内存。这种情况是最常用的。因为编译器生成的析构函数是不会销毁new出来的动态对象，这一点是因为new出来的对象保存在内存中的堆(heap)区，而编译器生成的析构函数只会释放内存中的栈(stack)区。

 

显式定义的析构函数的作用不像显式定义的构造函数那么有用，显示定义的析构函数完全可以用别的函数代替，但是，为了使用方便，为了其它编程人员的使用，在需要显示定义析构函数的情况下，还是定义它比较好，这样符合通用编程风格。

 

7.   友元函数和友元类

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。

友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

 

1)     友元函数
可以访问类的私有成员的非成员函数。它是定义在类外的普通函数，不属于任何类，但是需要在类的定义中加以声明。

friend 类型 函数名(形式参数);

一个函数可以是多个类的友元函数，只需要在各个类中分别声明。

 

2)     友元类
友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。        

friend class 类名; 

 

注： 

1) 友元关系不能被继承。 

2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 
3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

 

8.  Return Value Optimization

返回值优化(RVO）是一种编译器优化机制, 当函数需要返回一个对象的时候，如果自己创建一个临时对象返回，那么这个临时对象会消耗一个构造函数的调用、一个复制构造函数的调用以及一个析构函数（Destructor）的调用代价。而如果稍微做一点优化，就可以将成本降低到一个构造函数的代价,这样就省去了一次拷贝构造函数的调用和依次析构函数的调用。

 

在使用GNU/g++编译器时可以使用"-fno-elide-constructors"选项来强制g++总是调用copy构造函数，即使在用临时对象初始化另一个同类型对象的时候。

 

三种拷贝构造函数调用的时机

l  最明显的就是用一个类对象初始化另外一个对象的时候

l  函数的参数是类对象，这个是函数按值传参数的时候，包括指针在内都是对原有的值的拷贝. 函数返回一个类对象，这是一个对象以值传递的方式从函数返回. 

l  这些都只是语义上的分析, 现在编译器的编译策略, 很多情况下会把这些临时对象的创建都隐藏掉.

 

1)     命名返回值优化(NRVO)
函数中所有的返回语句全部是这一个对象的话，那么，命名返回值优化的作用就是，在这个对象建立的时候，直接在返回区建立。这样就使得函数返回时不需要调用拷贝构造函数了，减少了一个对象的创建与销毁过程。



2)     未命名返回值优化
在返回语句中直接创建一个临时对象并返回,指在返回语句中直接构造临时对象，这样就可以直接将临时对象构造在返回区中，节省了两个对象的创建与销毁的过程。

 

3)     隐式构造函数优化
当用赋值语句对一个对象进行赋值时，最一般的情况是先执行赋值号右侧的表达式，再将表达式的结果（一般是编译时产生的临时变量）赋值给对象。

然而，当用赋值语句对一个对象进行初始化时，则该表达式的结果就是该对象。即，不需要产生临时变量，而是直接将表达式的结果建立在该对象的位置上。

 

说明： 在栈空间中，调用函数时，会在压入实参之前，留下一个函数返回值的类型的大小那么大的空间，作为函数的返回区。而新建立的变量a，其地址恰恰就在返回区的这个地方，这两者是完全重合的。所以，在函数返回后，无需将函数返回值作为拷贝构造函数的参数去初始化a，而是什么都不用做。因为a所在的区域，就是函数的返回区域。

 

4)    无法进行RVO的情况
优化实现依赖于编译器，也就是说编译器只能对指定的符合其规则的代码进行RVO优化,对于不符合要求的却无能为力.

① 函数使用exeception, 为了保证异常的正确捕获, 编译器不会进行RVO 

② 不同命名的函数对象（Different Named Objects）, 这个情况是说，函数有可能有多个分支，最终导致有多个不同位置的return语句。对于此项优化，要求所有return返回的对象的名字都是一致的。如写成下面的情况，就不行：

Base Test( ) {

    if(...)    {

       return b1;

    }   else    {

      return b2;

    }

}

因此 优化的关键，就是最好只在一个地方返回。即函数只有一个出口

③ 嵌入的汇编代码中引用了返回对象。

 

示例：

return String(s1 + s2); 和 String temp(s1 + s2); return temp;

这是临时对象的语法，表示“创建一个临时对象并返回它” 。将发生三件事，首先，temp 对象被创建，同时完成初始化；然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；最后，temp在函数结束时被销毁(析构)；

然而“创建一个临时对象并返回它”的过程则不同，编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的耗费，提高了效率。

 

9.  override,overload,final

1)     override
虚函数总是在派生类中被改写，这种改写被称为“override”。派生类覆盖基类的虚函数，实现接口的重用，重写的函数必须有一致的参数表和返回值（C++标准允许返回值不同的情况，但很少编译器支持这个feature）。如名字打错，则编译器不会编译通过。为减少运行时错误，重写虚函数加上override。

不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字

 

2)     redefinition
派生类屏蔽了其同名的基类函数overwrite

不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字

 

3)     overload
指编写一个与已有函数同名但是参数表不同的函数。如，一个函数即可以接受整型数作为参数，也可以接受浮点数作为参数。 将语义相近的几个函数用同一个名字表示，但是参数和返回值不同，这就是函数重载

相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无

靠参数而不能靠返回值类型的不同来区分重载函数。

重载操作符要有充分理由,且不要改变操作符原语义，如不要使用 ‘+’ 操作符来做减运算。

 

虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态绑定的多态，而重载是静态绑定的多态。

名称

名字空间

区别

重载

overload

同一名字子空间

指允许存在多个同名函数，而这些函数的参数表不同。

重定义/隐藏

redefinition

不同名字子空间

用于继承，派生类与基类的函数同名，屏蔽基类的函数

重写/覆盖

override

不同名字子空间

用于继承，子类重新定义父类虚函数的方法，参数相同，virtual

 

不能被重载的运算符

有一些运算符是不允许被重载的。限制是出于安全方面的考虑，可防止错误和混乱。 
1）不能改变 C++内部数据类型（如 int,float 等）的运算符。 
2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。 
3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。 

4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。 

 

4)     final
当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final后被继承或重写，编译器会报错。

class Base{

    virtual void foo();

};

 

class A : Base{

    void foo() final;   // foo 被override且是最后一个override，在其子类中不可重写

    void bar() final;   // Error:父类没有bar虚函数可以被重写或final

};

 

class B final : A  {   // 指明B是不可以被继承的

    void foo() override; // Error: 在A中已经被final了

};

class C : B // Error: B is final

{

};

 

10.     接口定义事项

1)  用T* 或T& 作为参数
不涉及所有权的场景，使用T* 或T& 作为参数，而不是智能指针

说明：

l  只在需要明确所有权机制时，才通过智能指针转移或共享所有权.

l  通过智能指针传递，限制了函数调用者必须使用智能指针(如调用者希望传递this )。

l  传递共享所有权的智能指针存在运行时的开销。

 

示例

// 接受任何 int*

void F(int*);

// 只能接受希望转移所有权的 int

void G(unique_ptr);

// 只能接受希望共享所有权的 int

void G(shared_ptr);

// 不改变所有权，但需要特定所有权的调用者

void H(const unique_ptr&);

// 接受任何 int

void H(int&);

 

// 不好

void F(shared_ptr& w) {

// ...

Use(*w); // 只使用 w -- 完全不涉及生命周期管理

// ...

};

 

2)  接口层面明确指针不为nullptr
nullptr是为解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0

说明：

l  避免解引用空指针的错误。

l  避免重复检查空指针，提高代码效率。

建议使用 gsl::not_null ，或参考实现自己的版本（如使用 NullObject模式 ）。对于集合，在不违反已有的接口 约定的情况下，建议返回空集合而避免返回空指针，当返回字符串时，建议返回空串 "" 。

 

示例

int Length(const char* p); // 不清楚 length == nullptr 是否是有效的

Length(nullptr); // 可以吗？

 

int Length(not_null <const char *> p); // 更好：可以认为 p 不会是空指针

int Length(const char* p); // 必须假设 p 可能是空指针

 

通过在代码中表明意图(指针不能为空)，工具可以提供更好的诊断，如通过静态分析找到一些错误。也可以实现代码 优化，如移除判空的测试和分支。

注:  not_null 由 guideline support library(gsl) 提供

 

3)  函数的参数个数
函数的参数个数不超过5个。参数过多，可以考虑能否拆分函数或能否将相关参数合在一起，定义结构体。

 

4)   … …
