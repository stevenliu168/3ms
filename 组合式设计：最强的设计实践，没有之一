组合式设计：最强的设计实践，没有之一

无所不在的组合

组合：既可以作为名词又可以作为动词使用。作为名词，指由几个部分或个体.结合成的整体；作为动词，是指组织成整体。组合数学不仅在基础数学研究中具有极其重要的地位，在其它的学科中也有重要的应用，如计算机科学、编码和密码学、物理、化学、生物等学科中均有重要应用。

1      编程语言的实现
一个强有力的编程语言都会提供下面三种机制：

基本的表达形式，表示语言所关心的最简单的个体
组合的方法，通过组合可以从简单的东西出发构造成复合元素
抽象的方法，对复合对象进行命名
可以这么说，如果没有没有组合，就没有现在这些编程语言。大家都知道编程语言在进行定义构造和解释的时候都会定义一套BNF范式，我们简单来看看C语言的描述：



从这里可以看出，C语言可以通过一些关键字，标识符组合成表达式，再由表达式组合成函数，再由函数组合成模块，最后组合成一个程序，就是这种高度组合的能力，可以让我们的编程语言很方便地进行扩展而对于编译器的影响是最小的。

2      传统的依赖注入组合
在使用UML的时候，学习到了类关系：其中就有关联，组合，聚合，其实这三种都是广义的组合，通过对象的组合形成一个新的对象，来完成更多的功能。 比如在C++/Java里面：

class B;

class A

{

private:

B b;

}

这里的B可以是对象，引用或者指针，可以通过构造函数，setter等注入，在java里面也可以通过注解进行注入。不管怎么样，这是我们最传统的进行对象组合的方式。

3      Scala的Trait组合（Java8 的interface组合）
Scala中Trait可以理解为带有实现的接口，在Java8的Interface也具有这样的能力。

trait Logger{

def log(msg: String)

}

 

class ConsoleLogger extends Logger{

def log(msg:String){println(msg)}

}

 

class ConsoleLogger extends Logger with Cloneable with Serializable

对于Scala来说，不仅仅可以在类上面进行Trait混入，也可以在某个对象上面进行混入。

class ConsoleLogger{}

val logger = new ConsoleLogger with Logger

4      DCI（Data, Context and Interaction）介绍
Tr ygve Reenskaug和James O. Coplienzai在考虑到MVC使用的一些问题和Scala的Trait特性的提出，提出了一种新的架构思路，就是把传统的领域对象分成Data, Context和Interaction）.

Data：就是表示纯粹的数据, 但是在实践中还是会将接口和数据封装在一起。
Context：就是一个可以使用领域对象的类，主要是业务流程，算法的实现，在这个过程中通过转换对象的Role来使用接口实现功能。
Interaction：就是在Context的多个Role之间的交互过程。
Role：就是将数据和基于这部分的数据的相关行为组合成一个角色。
Role就分为Methodful Role和Methodless Role。（就像是C++中的具体类和抽象类的区别），这个Role在DCI的论文中更像是Scala的Trait，不能和Data和Class混为一谈。
对于DCI来说，其实就是为了让程序更能表达对象，角色和协议的一种模型，让我们的代码更容易理解。
关于DCI这里不做过多的解释，我们看一张图就明白了：


这个上面说的就是Class通过组合MethodFul Roles完成对象的组合，然后Class实例化对象以后，对象对外就可以提供MethodLess Roles的能力，这个就是一个很明显的组合关系。

对于DCI的详细描述可以参见这篇论文(http://www.artima.com/articles/dci_vision.html)

5      C++的多重继承实现小类大对象的思想
在这里首先要理解类和对象区别：
类的作用，是为了模块化，我们应该遵从高内聚低耦合的原则去划分类，那怕由此产生了远超领域实体概念数量的类，也无妨。让软件容易应对变化，是我们无论采取何种方法论都应该遵从的原则。

而对象，是我们运行时承载了数据和行为的实体：它的种类和数量应该与领域的真实概念存在清晰、明确、直接的映射。

因而，类应该是小的，对象应该是大的。上帝类是糟糕的，但上帝对象却恰恰是我们所期盼的。

所以我们在类的设计的时候，一定要秉承单一职责的原则，每个类尽可能的小，但是在的对象的构造上，将对象映射到真实的领域对象，增加了可理解性，也让对象真正地反映我们的业务领域。

在C++中，可以通过多重继承将类映射到对象， Scala中可以通过Trait， Java8可以通过Interface。

具体小类大对象的使用可以看后面的案例总结1.
我们可以看到小类大对象和DCI虽然出发点不一样，但是最后却达到相同的效果，就是将小的类组合成一个大的对象。

小类大对象具体请参见 http://3ms.huawei.com/hi/blog/40602_2197329.html?h=h

6      GoF设计模式中的组合运用
在GoF的设计模式中，大部分都可以体现组合式的设计思维，我们可以简单看看策略模式，组合模式与装饰者模式。

策略模式：本质上就是一种组合设计，用户只需要把策略组合在不同的上下文中，就可以实现特定的需函数式编程中的函数组合求。
组合模式：这是组合式设计玩到极致的模式，不仅仅把一些类组合在一起，并且组合完成以后对外的呈现和每个组合子的接口还是一样的，一般来说组合模式就是一种树状结构。
装饰者模式：这个也是通过组合将若干类组合在一起，对外还是提供相同的行为，与组合模式不同的是，这个一般是一种链式结构。
7      函数式编程中的函数组合
在函数式编程中，函数是一等公民，可以通过函数组合和高阶函数的能力形成最小粒度的复用，这个也是FP一直引以为傲的地方，比OO可以更小粒度的复用。

函数组合

我们可以通过函数组合的方式来实现一个新的函数：

ff :: [Int] -> String

ff = show . foldl (+) 0 . filter (>2) . map (1+)

这样ff通过show foldl等函数组合出来的新函数，你只需要把这个新函数apply在某个集合上面就可以完成特定功能。
在Scala中，可以通过compose，andThen来实现组合

def f(s: String) = "f(" + s + ")"

def g(s: String) = "g(" + s + ")"

val fComposeG = f _ compose g _

val fAndThenG = f _ andThen g _

高阶函数： 函数如果参数一个函数或者返回一个函数，那么就是高阶函数：

map :: (a ->b) -> [a] -> [b]

filter :: (a -> Bool) -> [a] -> [a]

foldl :: (a -> b -> b) -> b -> [a] -> b

我们以filter为例，这个高阶函数有一个参数一个函数，用来制定过滤的策略，所以我们可以将a -> Bool和filter本身这个函数进行组合，就形成我们业务就需要一个功能，这个和OO里面的策略模式本质上一样的。

单继承和组合的区别和适用场景

继承只能处理单一方向的方向变化问题： 如果你的祖先类比较复杂，职责比较多，那么每一个职责就有可能出现变化，那么就会派生出一个子类，那么这样就会出现一个庞大的继承树，并且继承树里面会出现重复的实现。这就是单继承所带来的问题，所以单继承只有在同时满足两种场景下才使用：

基类和子类的确是IS-A的关系
基类只有一个变化方向
单继承不适用的场景：

从这里就可以看出，如果f和g同时变化，那么就会出现4种组合，并且子类里面还有重复，如果变化方向更多，那么组合也就更多，最后形成一个庞大的继承树。

如果不满足上面的要求，那么就考虑使用组合的方式来实现，具体实现的方法上面已经写了很多：

传统的依赖注入组合
C++的多重继承组合
Scala的Trait组合
Java8的Interface组合
在现实大世界中，组合模式比单继承适用范围更广，更灵活，所以我们在软件设计和实现的实现如果出现了比较庞大的继承体现，就需要考虑一下是否用组合更适合？

组合使用的案例总结1：某云核心网产品中通过小类大对象的思想和C++多重继承思想实现

在产品中，有一个庞大的角色，叫用户类，起初这个只是一个纯粹的数据结构，数据和算法的分离的，为了使用封装，来提高耦合和重用。

初步是使用这样的方式实现：

这个是明显的上帝类，职责太多了，违反了高内聚低耦合的原则。

后面想使用面向对象继承的方式实现：
这种实现方式有一些缺点
用户类还是职责太多，依旧是上帝类
派生出来的子类的各个变化方向不一样，每个子类可能有独特的实现是其他兄弟类没有的
派生出来的子类有一些重复的实现
最后使用对象组合的方式来实现


 

通过这种实现方式，其实一种倒置继承树，所以没有违背IS-A的语义，不同的对象可以根据自己的真实概念逻辑选择实现部分角色。
并且图中的Subscriber， 普通用户，企业用户，主从用户这些类都是承担组合器的功能，那么这些对象之间是怎么组合起来的呢，可以通过下面的例子可以看出来：


1.     简化了组合方式

2.     内存管理更加容易

3.     工厂的实现更加方便

4.     对象之间的依赖更加清晰，代码的可溯性更强

5.     对象和角色的自动转换

 

组合使用的案例总结 2：通过DSL来解决异步通信场景下状态机的复杂度

在产品中会经常有大量的异步交互的流程，比如两个系统之间的发送Diameter消息，一般会采用状态机来实现，这样状态机里面有出现：

非常多的临时状态，而不是系统真正的状态
流程如果发生变化，就要开始修改状态机的实现
状态机和业务代码是耦合的。
为了解决这一点，使用Transaction DSL来进行处理
先定义单独的业务Action：


然后将这个Action进行组合起来



通过这样的处理，可以达到如下效果：

对于异步流程的直接描述
节省了状态机本身的维护工作
业务代码和流程代码各自变化，互不影响
绝大多数Action之间也是正交关系
Action被当做一种组合原子，可以在任意流程，以组合的方式进行复用
总结

大家可以想象一下，如果我们的程序如果想变形金刚那样可以任意排列组合，然后形成一个新的功能，那么我们的软件架构的扩展性是多么灵活，并且可以以最大程度复用现有资产（函数，类，模块，微服务等），所以以后大家在设计中看到Combination, Combine, Composite等字样的时候，就应该知道这是一个很不错的设计了。

并且从前面可以看出，通过组合式设计，可以让我们的系统更容易，也更低成本演进。
