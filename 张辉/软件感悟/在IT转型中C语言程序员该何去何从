http://3ms.huawei.com/km/blogs/details/2478329

在IT转型中C语言程序员该何去何从

随着公司全面云化转型和CloudNative架构的演进，公司2012和各个产品线都在推行新语言（Java/Scala/Go/Typescript/C++11等)，C语言的将会比重越来越低。那么传统的C语言程序员该如何应对这一次云化转型，让自己可以快速地使用新语言新思维进行开发？

如果你后续还是从事Linux相关内核的开发，从事受限的嵌入式开发，高性能硬实时系统那么C语言还是首选。 如果是要从事基础设施类高性能类的开发那么C++还是首选，或者从事上层Saas的开发，那么Java/Scala这些高抽象语言就是首选。

仅仅是学习新型语言就行了吗

这是很多人都第一反应, 针对语言转型还不容易，学一门新语言就行了，那都是很简单的，比如Go,Java都很好学。

但是C程序员都很多不好的编码习惯，由于过程式编程和C语言本身的原因被掩盖了，如果到了新的高级语言，这种坏习惯就会被放大，就像当初C++被很多人骂一样，其实都是因为一帮不合格的C++程序员在写C++。

我们经过分析，看到C程序员转型到Java以后写的代码的主要问题（即使是从开始就是OO程序员，也有很多同样的问题）：

代码大量重复
由于在C语言里面的数据和算法是分离，然后消除手段的手段比较困难（比如泛型，多态等），所以经常出现重复的代码。 等到了面向对象开发的时候，依旧是大量的重复， 类的数据，类的行为有重复，没有掌握基本的技巧的消除这种重复。

类的职责不明，总是出现所谓的Controller，Manager, Handler， Util类
很多人都觉得类名很难起，根本原因是因为你没有职责划清楚，如果出现Manager类，那说明这个类的行为可能是属于某个具体的类，而不是按照面向过程的思维把一些操作封装成一个所谓的class而已。

喜欢使用类带有静态方法
很多时候静态方法都应该是属于某个对象的，仔细观察静态方法的参数就明白了，但是因为传统C语言的编程习惯，不知道该如何划分职责，只能使用静态方法。

通过getter和setter暴露数据，看似封装，其实不然
很多人认为使用了Java或者C++提供的private修饰符就是封装了，然后把数据通过getter和setter接口暴露出去。这样的的确比C语言强那么一点点（起码字段名外边不依赖了），但是使用数据的地方却和C语言的结构体差别不大。

模块划分有问题，总是按照流程来划分模块，而不是按照职责来划分模块，导致模块之间耦合很严重，比如耦合全局数据结构等
所以，学习什么语言不是重点，更重要的是一种编码思维，我们都希望开发的软件是高内聚低耦合的，是模块化局部影响的，语言只是提供了更好的手段，而我们在面向对象中推崇的封装，继承和多态都是一种技术手段，最终都是为了更好的模块化服务的。

面向对象作为一种编程范式，是为了解决模块化的问题，让系统更容易进行模块划分，模块之间更好管理，让所有的变化都是局部化的影响。如果能够理解到这一点，学习什么编程语言都只是一种工具而已。

我们先看看如何运用C语言来实现面向对象里面强调的封装，继承和多态，来达到模块化的效果的
看看一个用C语言实现PAXOS算法的开源库，一般来说，实现算法的库完成算法就行，代码估计很晦涩难懂，但是我看了这个库的实现，C语言的代码写的就非常漂亮。我们拿其中一个模块的头文件来看看

信息隐藏–封装

struct learner;

 

struct learner* learner_new(int acceptors);

void learner_free(struct learner* l);

void learner_set_instance_id(struct learner* l, iid_t iid);

void learner_receive_accepted(struct learner* l, paxos_accepted* ack);

int learner_deliver_next(struct learner* l, paxos_accepted* out);

int learner_has_holes(struct learner* l, iid_t* from, iid_t* to);

从这个头文件来看，可以看出这个模块提供一个数据的构造/销毁器，还有若干方法。从这个头文件就可以看出，真正的数据结构被封装了，只有一个前置声明struct learner;
这种方式其实和面向对象的方式是很像的，封装数据，提供public方法。

再来看看实现c文件：

struct instance

{

    iid_t iid;

    ...

};

KHASH_MAP_INIT_INT(instance, struct instance*)

 

struct learner

{

    int acceptors;

    ...

    khash_t(instance)* instances;

};

 

static struct instance* learner_get_instance(struct learner* l, iid_t iid);

static struct instance* learner_get_current_instance(struct learner* l);

在c文件中进行数据结构的定义，进行封装，那么还有一些static的方法是干什么用的呢？
其实就是我们在面向对象所说的私有方法， static表示这个函数的是文件作用域的，其他的编译单元是无法使用这个函数的。

我们再来看看对外接口的实现：

void learner_set_instance_id(struct learner* l, iid_t iid)

{

    l->current_iid = iid + 1;

    l->highest_iid_closed = iid;

}

 

int learner_deliver_next(struct learner* l, paxos_accepted* out)

{

    ...

    l->current_iid++;

    return 1;

}

从这样的代码第一反应：代码清晰，函数代码行数少，圈复杂度低。

由于将数据结构封装了，所以所有的API都是在操作这个数据结构，我们看看每个函数的第一个参数，都是结构体的指针，这个和C++成员函数隐藏的this指针是相同的效果。
函数的职责很清晰，每个函数都很小。到底写圈复杂度小的函数容不容易。其实很容易，只要追求单一职责，然后通过正交设计的手段进行职责分离，然后通过C++/Java/Scala这些语言提供的丰富手段（比如面向接口编程，泛型编程，组合等等方式），要达到单一职责还是很容易的。C语言虽然手段贫瘠一些，但是也是可以做到的。
我一直是进行面向对象语言开发的，使用C++/Java这些抽象能力好的语言进行开发。然后通过对象的封装，继承，组合和多态完成模块化，让每个模块的代码都很清晰，边界很清晰。我以前看到很多公司很多C语言代码，我一直就有一个疑惑，C语言到底能不能写出好的代码，是不是所有的C代码都是这样的：

接口归一化–多态

在面向对象中，还有一个重要的特性就是多态，但是多态只是一个手段，真正的目的是为了实现归一化，让模块之间的耦合更抽象，更不容易变更，这样才可以更好实现所谓OCP原则，达到真正解耦。
那么C语言如何实现多态这种特性了，其实就是用函数指针来实现，比如在这个例子中，有一个存储的功能，但是就像策略模式一样，有几种实现的方式，但是结构是一致的，那么就可以通过函数指针来实现： 万能的void*

struct storage

{

    void* handle;

    struct

    {

        int (*open) (void* handle);

        void (*close) (void* handle);

        ...

    } api;

};

 

int storage_open(struct storage* store);

void storage_close(struct storage* store);

...

int storage_open(struct storage* store)

{

    return store->api.open(store->handle);

}

 

void storage_close(struct storage* store)

{

    store->api.close(store->handle);

}

这里定义的storage就是一个策略ADT，包括操作的数据和操作的接口

然后通过方法来初始化storage，然后通过提供的storage_xxx方法来进行调用，这样业务和storage的具体实现是正交的，业务流程只关注storage的外部接口，对于storage的内部实现不关心，这样后续扩展新的storage的时候业务流程是不用修改的。

继承

其实C语言是无法实现真正意义上的继承，就像现在Go语言一样，只能通过组合来模拟继承，这里就不赘述了，这种方式我更喜欢直接叫做组合。没有真正的is-a的语义了。

我们在用C语言进行编码的时候一般会有哪些问题呢？

数据结构太大了，已经失去了领域对象的意义，纯粹是一个数据块，这样会让代码实现和领域脱离，不好理解。
数据结构和算法耦合太严重，内聚性太差，导致结构体的修改很容易导致影响算法的修改
很容易出现重复，因为算法都是基于结构体数据的操作，但是每个算法都操作字段的时候，你是不知道其他的地方是否有操作，这样就很容易写出功能相同的代码。
没有模块的概念， 所有相近的数据结构放在一起，差不多的函数随放在一起。
但是上面通过很好的模块设计来避免了这些问题，也就是说即使使用C语言，我们也可以达到模块划分清晰，模块内高内聚，模块间低耦合的，只不过手段比较麻烦而已。

所以面向对象提供的封装，继承和多态的这三种手段可以更好地解决模块化的问题，从语言层面给予支持。但是我们需要记住一点，面向对象的封装，继承，多态，只不过是手段，真正的目的是为了隐藏，追求模块化，追求高内聚低耦合。从这个真正的目的触发，C语言虽然从语法特性来支持不够，但是通过ADT的思想还是可以实现。
所以从C语言转向OO语言以后，不要过度地追求继承，多态等特性，记住这个仅仅是手段，不是目的，我们的目的是为了更好地模块化。

C程序员最重要的还是思维的转变

模块化就是：按照单一职责划分模块，每个模块做到局部化影响，模块与模块之间是低耦合的，依赖抽象， 模块和模块可以通过很方便的手段进行组合。

如果将从C语言转向更高阶的语言，那么更重要的模块化的思维转换，而不是简单的编程语言转换
如果我们依旧留守在C语言的阵地，那么也需要好好学习模块化思维，来指导C语言的模块设计
如果我们已经是OO语言或者FP阵地的，模块化思维就更重要了，否则写出来的代码那么将是灾难性的
只有这样，具有优秀的软件设计和模块划分的思维，那么你用什么语言编写的代码都应该是不错的，如果不具备这种思维，那么无论你是使用简单的C语言，还是使用复杂的Scala，代码一定是相当ugly和boring的，难以维护的。

我一直觉得使用什么语言并不是最重要的，最重要的是解决问题，并且体现出你对代码架构的设计能力。
所以，软件转型，从思维转型开始….



后记

和云核某个产品做完一次技术交流以后，发现大家现在被公司IT转型和2012推行新语言弄得比较紧张，感觉不学习，不转换语言就要被淘汰了。我觉得大部分遗留产品过于紧张了。所以写了这篇博客，来阐述一下我的观点：

编程语言是为了解决问题的，而不是盲目追从的
相对编程语言，代码架构的设计能力更为关键。（这里不是说编程语言不重要， 只有你真正理解了软件设计，再加上高效的编程语言，那么将是事半功倍。）
相比学习新语言，学习新架构模式，先把软件设计的基本思维训练好， 怎么做模块设计，怎么软件解耦，这些如果都不掌握，给你再先进的工具方法只会更糟。
语言学习的成本相对软件思维的学习成本是要低得多的，知识的获取的也是更廉价的。
所以，对于现在华为大部分C程序员或者其他程序员，不要被现在的新语言，微服务这些概念所吓倒，从自己产品的特点和问题出发，找到最好的解决方案就行，而语言和架构都是支撑的工具。 做好基本的软件设计，结合高效的编程语言，这样才能真正提高我们的开发效率。
