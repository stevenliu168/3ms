三. 软件架构的灵活设计
软件组件模块之间松耦合常见有两种方式：接口和消息，这两者如同人的骨关节一样，连接着松耦合的双方。消息比接口更加松耦合，因为接口方法有可能改变，导致接口的使用者跟着变化，而通过消息，消息生产者只要发送消息到消息系统就可以了，不再管是谁来接受消费这个消息，消息生产者由此和消费者完全解耦了。设计示例：

复杂性

假设原来是只有两个组件进行交互：



需求不断扩展变化，增加了第三个组件，那么这三个组件之间任意交互，复杂度就会提高：

   

复杂度以指数级的增长是惊人的，当我们增加到六个组件，复杂度将是惊人的。

 

自然界是如何应对这复杂呢？在物理中被称为构造定律。构造定律致力于描述能量和物质在物理网络(如河流)和生物网络(如血管)中的流动，理论提出，如果一个流体系统要继续存在(比如，生存），那它必须始终提供更容易的方式来获得这个系统中的流体。换句话说，系统应该致力于将能量消耗减少到最低限度，而同时将消耗单位能量产生的熵提高到最大限度。进化实质上是这么一个过程，即生物体不断的重组他们自身，以使能量和物质能够尽可能迅速高效的通过他们。更好的流体结构，不管它们是动物还是河流，将取代那些较差的结构。

 

如何设计出一种结构以促成流经这个结构的用户请求能更有效地获得响应呢？很显然，多个组件发生任意关联的方式肯定是不经济的，熵值副作用很大，如果变成以下这种结构，组件能够实现分组，三个元素是一组，另外一组是四个元素，组与组之间通过一个代表元素关联：



单一职责功能是关键，意味着只做一件事。它与让事情DRY原则是一致的：每一个知识都必须有一个单一的、明确的、在一个系统内的权威明确表示。不要重复，需要干脆。程序中的每一个重要的功能都应该在源代码中的一个地方实现，将业务规则、长表达式，if语句、数学公式和元数据等各自放在一个地方。单一职责也与委托原则有关，只有放弃一些才能获得一些，有舍有得，放弃的就是委托其他类实现：不要自己做所有的事情，可以委托给相应的类去完成。因为每个组件都秉持单一职责，组件之间才可能发生唯一的一个关联关系。

 

高凝聚意味着模块的复杂性降低。因为变得有条理，复杂性自然降低。组件之间的强关系用耦合表达，保留下好的强关系也就是高凝聚，去除不好的强关系也就是低耦合。高凝聚、低耦合是降低复杂性提高灵活性设计中重要的宗旨。

 

除了静态的结构关系以外，高凝聚、低耦合还表达为对象的方法行为上，这需要通过分配职责来实现。什么是职责？它包括三个方面：

1)   对象应该执行的动作；

2)   对象包含的知识如：算法 约束 规格 描述；

3)   当前对象影响其他对象的主要因素。

以报童向买报人收钱为例：报童应该向顾客收取两块钱的买报费，他是直接把顾客的钱包拿过来从中掏出两块钱，还是请求顾客自己从钱包里掏出两块钱呢？无疑是后者。

这两者的区别是什么？Tell, Don't Ask原则：

报童只要告诉顾客做什么，而不直接参与怎么做(你的钱够吗？够才能买)。报童只给顾客一个命令，而不必关注顾客是如何执行这个命令。Tell, Don't Ask原则能够让我们保证两个组件之间在动作上不会发生过于细节过多的耦合，而只是通过一个消息就能完成，通过发送消息告诉对方我需要什么，而不是直接把对方拎过来搜身。至此，完成了两个组件之间最大松耦合，实现了架构设计的最大可能的灵活性。



软件架构复杂性必然如自然界任何事物一样不断发展，作为软件架构师如何学习大自然的巧妙设计，如同庖丁解牛一样切分复杂性为单一职责，再从结构和行为的高凝聚关系方面进行组合或消息传递，从而真正实现高凝聚、低耦合的灵活性目标。

 

四. 典型架构对比分析
系统架构跟随技术的发展不断升级和改进，从传统的单一架构演变为分布式、微服务架构、Serverless架构，以下列举了主要的四种软件架构以及它们的优缺点。

1. 单体应用架构
单体架构的应用开发简单，易于更改，测试、部署简单及便于横向扩展。但随着需求不增加，管理成本也不断提高，代码库飞速地膨胀。慢慢地单体应用变得越发臃肿、复杂、不可靠，可维护性、灵活性逐渐降低，维护成本越来越高。单体程序陷入单体地狱，开发变得缓慢和痛苦，敏捷开发和部署已经不可能。应用变更后，开发团队将其更改提交到单个源代码仓库，从代码提交到生产环境的路径漫长而艰巨。

问题点：

l  过度复杂：以一个百万行级别的单体应用为例，整个项目包含的模块非常多、边界模糊、依赖关系不清晰、代码质量参差不齐、混乱地堆砌在一起，可想而知整个项目非常复杂。每一次更改都会让代码库变得更复杂、更难懂。应用一步一步地成为一个巨大的、令人费解的“脏泥球”。

l  开发速度缓慢：IDE工具使用变慢，构建一次应用需要很长时间，应用太大导致每启动一次都需要很长时间。从编辑到构建、运行再到测试这个周期花费时间越来越长，严重影响团队的工作效率。

l  部署频率低：代码增多，构建和部署的时间也会增加。每次功能的变更或缺陷修复都会导致需重新部署，全量部署耗时长、影响范围大、风险高，使得应用上线部署的频率较低,出错率较高。

l  扩展能力受限：单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。

l  可靠性差：程序体积庞大而无法进行全面和彻底的测试，意味代码中的错误进入生产概率大。所有模块都在同一进程中运行而缺乏故障隔离，一个模块中的错误将导致所有实例崩溃。

l  阻碍技术创新：体现在团队必须长期使用一套相同技术栈，采用新的框架和编程语言变得极困难。采用或尝试新技术极其昂贵和高风险，因为应用必须被彻底重写。

 

2. 分布式体系架构
随着业务的深入，要求的产品功能越来越多，业务模块逻辑也变得更加复杂，使得单体应用变得越发臃肿，可维护性、灵活性降低，开发周期越来越长，维护成本越来越高。此时需要对系统按照业务功能模块拆分演变成一个分布式系统，将业务模块部署在不同服务器上，模块之间通过接口进行数据交互，通过负载均衡结构提升系统负载能力。



架构特点介绍

·       降低耦合：把模块拆分，使用接口通信, 降低了模块之间的耦合度；

·       责任清晰：把项目拆分成若干个子项目，不同的团队负责不同的子项目；

·       扩展方便：增加功能时，只需要再增加一个子项目，调用其他系统的接口即可；

·       部署方便：可以灵活的进行分布式部署；

·       提升代码复用：采用分布式服务方式构建公用服务层，减轻开发量。

缺点：系统之间交互使用远程通信，接口开发工作量增大。

 

3. 微服务化架构
参考博客：【微服务架构及ServiceMesh技术框架介绍】

由松耦合和具有边界上下文的元素组成，是将应用程序功能性分解为一组服务的架构风格。每个服务都是由一组专注的、内聚的功能职责组成，使用服务作为模块化的单元。服务的API为它自身构筑了一个不可逾越的边界，无法越过API去访问服务内部类。可为应用程序提供更高的可维护性、可测试性和可部署性，同时提升了开发效率、应用可扩展性等。服务的本质是围绕业务而非技术问题进行组织的，反应业务语义、自包含、无状态、跨边界。



定义微服务架构

使用更抽象的系统操作概念将应用的需求提炼为各种关键请求，系统操作是描述服务之间协作方式的架构场景；然后确定如何分解服务，有几种策略, 一种是定义与业务能力相对应的服务, 另一策略是围绕领域驱动设计的子域来分解和设计服务，每一服务都有它自己的领域模型。策略围绕业务而非技术概念分解和设计服务，策略的结果都是一样的：一个包含若干服务的架构，是以业务而不是技术概念为中心；最后是确定每个服务的API。

 

将标识的每个系统操作分配给服务,服务可独立地实现操作或可能需与其他服务协作。服务的分解需考虑网络延迟, 自包含，跨系统边界的数据一致性等，使用领域驱动设计中的概念来消除所谓上帝类。每一个系统操作的行为都通过领域模型的方式来描述，每一个重要的系统操作都对应着架构层面的一个重大场景，是架构中需要详细描述和特别考虑的地方。

 

进行微服务拆分

领域驱动设计是构建复杂软件的方法论，这些软件通常以面向对象和领域模型为核心。领域模型以解决具体问题的方式包含了一个领域内的知识。它定义了当前领域相关团队的词汇表，DDD也称之为通用语言。领域模型会被紧密地映射到应用的设计和实现环节。在微服务架构的设计层面，DDD有两个特别重要的概念，子域和限界上下文。

 

传统企业架构建模方式往往会为整个企业建立一个单独的模型，会有适用于整个应用全局的业务实体定义，例如客户或订单。这类建模方式会带来譬如一致性、复杂性及不同团队使用上的混乱等问题。DDD采取完全不同的方式，定义多个领域模型来避免，每个领域模型都有明确范围，领域驱动为每一个子域定义单独的领域模型。子域是领域的一部分，领域用来描述应用程序问题域的一个术语，识别子域的方式跟识别业务能力一样。DDD把领域模型的边界称为限界上下文，限界上下文包括实现这个模型的代码集合。在微服务架构中，每一个限界上下文对应一个或者一组服务。每一个子域都有属于它们自己的领域模型。



微服务架构好处

1) 使大型应用可持续交付和部署

持续交付和持续部署是DevOps的一部分，DevOps是一套快速、频繁、可靠的软件交付实践，高效能的DevOps组织通常在将软件部署到生产环境时面临更少的问题和故障。微服务架构通过以下三种方式实现持续交付和持续部署：

·       拥有CI和CD所需的可测试性: 自动化测试是持续交付和持续部署的一个重要环节。每一个服务都相对较小，编写和执行自动化测试变得很容易，应用程序的bug也就更少。

·       拥有CI和CD所需的可部署性: 每个服务可独立于其他服务进行部署。如负责服务的人员需要部署对该服务的更改，无需与其他人员协调就可进行。因此，将更改频繁部署到生产中要容易得多。

·       实现团队的自治(自主且松耦合): 将组织构建为一个小型团队集合。每个团队负责一个或多个服务的开发和部署, 可独立于所有其他团队开发、部署和扩展他们的服务，提升了开发效率。



2) 服务较小且易维护

每个服务都较小,开发者更易理解，较小规模的代码库可提升开发者的工作效率，而整个应用是由若干微服务构建而成，所以也会被维持在一个可控状态。快速启动的服务能提高效率，加速研发过程。

3) 服务可独立扩展

支持不论是采用X轴扩展的实例克隆，还是Z轴扩展的流量分区方式。每个服务都可部署在适合环境。

4) 更好的容错性

可实现更好的故障隔离。如某个服务中的内存泄漏不会影响其他服务,其他服务仍可正常地响应请求。

5) 技术栈不受限

可结合项目业务及团队特点合理选择技术栈。这跟单体架构是完全不同，单体架构之下的技术选型会严重限制后期新技术的尝试。

 

微服务架构弊端

·       服务拆分和定义的挑战：服务的拆分和定义更像是一门艺术。如果对系统的服务拆分出现了偏差，很有可能会构建出一个分布式的单体应用：一个包含了一大堆互相之间紧耦合的服务，却又必须部署在一起的所谓分布式系统。将会把单体架构和微服务架构两者的弊端集于一身。

·       分布式固有复杂性：系统容错、网络延迟、数据一致性、分布式事务等都会带来较大挑战，服务必须使用进程间通信机制。此外，必须设计服务来处理局部和远程服务不可用/高延迟的各种情况。

·       运维要求较高：单体架构中只需保证一个应用的正常运行，而在微服务中需要几十甚至几百个服务的正常运行与协作，给运维带来了挑战。要成功部署微服务，需高度自动化的基础设施。

·       协调更多开发团队：当部署跨越多个服务的功能时需要谨慎地协调更多开发团队，必须制定一个发布计划，把服务按照依赖关系进行排序。这跟单体架构下批量部署多个组件的方式截然不同。

·       接口调整成本高：服务间通过接口通信。如修改某一微服务，可能使用了该接口的微服务都需调整。

·       重复性工作可能：很多服务可能会使用到相同功能，而该功能并未达到分解为一个微服务程度，可能会导致对这一功能的重复开发，尽管可使用共享库来解决但需面对多语言环境问题。

 

微服务架构已成为任何依赖于软件技术的企业业务的重要基石，是一把好处和弊端共存的双刃剑。在使用微服务架构时，一些问题无法回避，每个问题都可能存在多种解决办法，同时伴随着各种权衡和取舍，并没有一个完美的解决方案。

 

4. Serverless架构
低运营成本，简化设备运维，提升可维护性，更快的开发速度等。

参考博客：【云计算的可信下半场-无服务器 Serverless】

  

五. 服务化构架之可信谈
微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通。每个服务都围绕着具体的业务进行构建，架构上可为应用程序提供更好的可维护性、可测试性和可部署性，以及快速迭代和交付能力等。


说明：对本章节的理解需要一定的微服务化架构基础知识。

参考博客：【微服务架构及ServiceMesh技术框架介绍】【ServiceMesh-服务注册发现的应用适配】

     【ServiceMesh-Istio流量速率限制介绍】 【云原生零可信网络下 - 应用服务的安全】


1.  注册中心与配置中心
很多人经常把注册中心和配置中心混为一谈，有这种观点的认为服务注册数据其实就是配置的一种，这样解释也不无道理，的确注册中心的数据是配置的一种。但注册中心之所以独立存在，那是因为注册中心的数据有一定的业务独立性，是为了描述微服务相关。注册中心完全不依赖配置中心，而是一个独立的、高可用、数据一致的系统。设计意识形态上要清晰注册中心和配置中心的用途实质，区分是服务的注册/发现，还是配置的登记与更新、通知。

·       注册/反注册：保存服务提供者和服务调用者的信息；

·       订阅/取消订阅：服务调用者订阅服务提供者的信息，支持实时推送。

 

2.  业务与技术面的解耦
模块间交互越多，其耦合性越强，同时表明其独立性越差。耦合性是对模块间关联程度的度量，是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。耦合的强弱取决于模块间接口的复杂性、调用方式以及通过界面传送数据的多少。

 

需要将业务和服务治理中间件能力分离，否则异构的业务必然带来服务治理能力的非标准化。应用与技术面的解耦可带来应用实现的语言无关性(Java/Go/Python/C++等), 应用升级维护的无感知，以及模块的扩展性、稳定性等。

l  应用与治理分离，业务应用和治理能力的就近物理切割。通过部署本地代理的方式来完成这个切割。

l  强调执行和控制的分离，也即控制平面和数据平面的切分。实现对业务进程的零/少侵入原则，将服务治理能力看待为协议栈的一部分。

https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hbnRjbG91ZC1jbmh6MDItYXRob21ld2ViLTAxLm9zcy1jbi1oemZpbmFuY2UuYWxpeXVuY3MuY29tL2ltYWdlLzIwMTktMTEtMDUvNTQ2NDM5NWItZGRmOC00ZjRhLWFiMGQtYzBiMzVlZGIxMzRhLnBuZw?x-oss-process=image/format,png

实践准则：

l 业务应用侧与服务系统平台内的各个模块的关系应该保持松耦合。

l 避免业务应用侧与数据面通讯模块的耦合，与通讯相关的功能应交由数据面通讯模块负责。在服务交互层面上,保持业务应用的轻形态,深入贯彻好信息专家模式。

l 避免业务应用侧的服务交互策略处理模式与注册中心分离。

l 避免业务应用侧进程内状态事件监测与传播的能量消耗的放大。

l 业务应用系统的敏捷化催生了开发的语言、技术实现的无关性，保持接口的兼容性。

……

 

3.  服务化的数据模型
系统关键数据模型，数据对象的生命周期等在设计之初就需明确和具有较为清晰的定义。数据模型是系统架构设计的重要组成部分，对模型对象的定义和使用，反向亦可折射出系统的架构设计的优劣。

l 服务对象模型是对服务的自描述，包含服务基础信息，环境信息、服务能力及Qos等。一个服务对象代表了一个服务整体，尽可能保持其无状态、自包含特征。对于有状态的服务可以建立数据存储(内存/SSD磁盘)关联。

l 服务对象模型为业务相关性，对于基础技术的能力也可发布成为一类服务，保持数据对象模型的一致，两者的区别在对象属性和操作特征上。

l 服务对象模型要保持原子性，如果硬性拆分成多个子对象且在系统内的不同场景使用，譬如拆分成：服务基础对象、服务交互对象、业务领域对象，控制策略对象等各个模型。必然给分布式系统的整体带来复杂性、稳定性问题。也使得模块间的耦合程度加大。

 

4.  服务的注册与注销
服务的本质反映业务语义，可包括多个方法，具有自包含特征。如订单服务包含有查询订单、新增订单等。每个服务实例需向注册中心来注册和解除注册,而注册中心主要起协调者的作用，可借助注册中心来发现已登记并可使用的服务。

 

l 服务的注册应该是极简模式, 意指服务实例只需完成注册、维持保活即可。需要对外提供服务的接口需要注册，进程内交互的无需对外发布。

l 业务应用侧将系统内的服务成功注册到注册中心，即代表了服务的生命周期的开始，宣告了业务应用侧的微服务接口的可用但并非可达。边车模式下还需等待进行服务发现。

l 对于服务使用方来说，需声明其需要的服务，及对其自身在该服务上的使用方式进行定义或默认策略。对于服务提供方，则需要定义服务的基础信息和能力模型(协议、并发、编解码，信息大小等等)，消费方的能力受限于服务提供方的能力输出。

l 基于业务领域服务和服务的交互形态，要明确哪些服务需要注册，是否反映了业务语义。登记注册在注册中心的信息必定是需要发现的关键资源，如果是来自业务应用侧的技术性的登记注册，应该从对象模型形态上构建关联，作为服务的属性(静态、动态)。

l 注册中心属于关键核心基础件，保障注册中心的稳定、可靠、高性能不仅需要其自身的优化，也需要关联方的最佳使用方式，在最合理的方式上来产生交互和信息传递。

l 业务应用与注册中心的直接交互为最佳实践，其它则会以牺牲简易、扩展、稳定为代价。

……

 

5.  服务的平台发现模式
服务消费方与服务提供方具有动态特征，需要登记到注册中心，包括两者的地址等环境信息。



l 客户侧服务发现模式，业务应用侧既要进行服务的注册，也要承担服务发现的职责。在分布式体系的生产集群环境，所有的业务进程都会存在与注册中心的Watch订阅，获取注册中心的服务关联方信息的推送。缺陷为订阅/推送的点过多，注册中心也需要为此产生一定的资源消耗，关联的点越多，消耗越大。

l 在通讯边车模式下，服务交互、路由等需经过数据面来处理，可由控制面适配层来提供服务发现，服务端和客户端不必承担服务发现职责。相比客户侧发现模式，订阅及信息推送的量只有原来的 1/N，大幅、有效减轻了注册中心压力。（服务对象模型要保持唯一性，避免注册信息与通讯模型对象的分离），同时，也进一步解耦业务应用侧与其它模块。

l 对于需要从注册中心获取登记的基础服务(譬如存储服务), 可结合查询方式和保底原则，减少不必要的向注册中心的订阅与事件触发后的信息推送。

 

6.  控制面适配层的职责
控制面适配层的职责在于对接通讯边车模块，实现控制指令下发、路由、负载、流控、熔断、安全等与服务治理相关的策略的管理。

l 与数据控制面适配层交互的模块包括：注册中心，各POD内的通讯边车模块进程，状态监控模块，管控(控制面)模块。与注册中心交互进行服务发现及实现与服务生命周期相关的操作；从管理控制面获取管控策略及安全策略；从状态监控模块获取业务应用侧事件状态并联动业务侧边车模块。

l 控制面适配层模块，业务应用侧程序两者应无实质性直接交互，要实现解耦。如产生耦合则会增加系统的复杂度。解耦方式可通过借助API接口来实施或委托隔离。

l 订阅全局服务信息并进行集中控制，需确保控制面适配层的可靠、稳定性，无单点问题。

l 对于策略、控制信息等需要确保可靠下发。

 

7.  服务调用与数据通讯
业务应用程序将业务领域服务，包括服务基础信息、实例环境、服务能力(Qos等)向注册中心登记，即开启了服务的生命周期。通讯的方式承载了服务与服务之间的交互，好的构架应该将数据面通讯模块的交互关系降到最低。

l 服务注册完毕即对外宣告了其微服务组件的声明式API。在边车模式的体系架构下，服务的调用需要数据面提供的信息路由，将请求提交给服务提供方来处理。

l 服务的交互是面向接口的调用，实例名信息、类别(请求方|提供方等)、环境信息等用于跨进程的寻址，而接口方法名用于进程空间内的回调，名称的可理解性、辨识性要好于数字标识。简单原则，能只依赖静态信息的绝不使用动态特征，减少系统的可变性依赖、耦合，特别是分布式系统场景，要减少子系统与子系统，模块与模块之间的耦合依赖。

l 通讯链路的设计原则，应该致力于将能量消耗减少到最低限度，将链接精准建立在必须的场景。避免链路的密集交互，大量的文件句柄，取代那些较差的结构。提升系统的整体稳定性，以及减少了分布式系统整体的资源消耗，包括计算、内存及带来的过多消耗导致的垃圾回收异常问题等。

l 数据通讯模块要确保高内聚、低耦合，主要职责在服务信息路由、负载均衡调度等服务治理相关。确保职责单一，要与业务应用侧尽可能的解耦。如果业务应用侧兼有路由控制则导致通讯控制职责分散，给系统带来复杂性，同时不利系统横纵扩展、不利业务实现的敏捷、不利高效交付等。也要避免引入与注册中心、状态监控模块的强关联。

l 外部系统可通过在服务注册中心获取服务的基础信息，或面向契约式地址的交互。通过数据面的路由抵达业务应用侧，可集中实施安全、审计、负载、流控等控制操作。

l 服务交互，通讯模式需要依据场景来提供同步、异步，请求的单向与双向等，在协议上可以考虑 HTTP, gRPC, REST，TCP/IP等的最佳适配,协议的使用做到可插拔。

l 通讯类型、模式、形态等尽可能保持一致，简化对外的操作形态，特别针对业务应用侧。提升系统对外接口操作的透明度，将处理细节封装在接口内部。

l 链路的可用性检测，隔离、熔断等服务治理操作职责尽可能限定在数据面的边车模块。

. . . . . .

 

8.  服务的治理、策略
服务治理是个非常大的话题，真的要铺开来讲，几篇文章的篇幅都谈不完。这里先简单地看一下服务治理要解决的问题。微服务化通过将复杂系统切分为若干个微服务来分解和降低复杂度，使得这些微服务易于被使用和维护。微服务的连接、服务注册|发现、路由、负载均衡、服务熔断、隔离，服务限流、降级，访问控制(认证、鉴权)、监控(日志、链路追踪、预警等)、AB测试，金丝雀发布等等，这些即是服务治理的内容。

 

在这里想说的是，每项服务治理的内容，都需要进行充分设计。需要清晰定义治理的目标，数据模型，治理策略的下发，治理实施的最佳控制点(确保职责单一)及联动模块，最佳的控制流、事件信息流，治理的关键路径(降低耦合)，治理期间的周期性活动，治理的边界，治理对各个模块的侵入最小化，治理对资源的消耗，治理的总体可控，接口使用透明等等。治理是服务的治理，从数据模型上尽可能与服务对象模型融合。

 

服务流控：流控的能力必须要有但要慎用。流控要体现在服务面上(某种程度上反映了服务提供方的能力限定)，策略模型与服务领域模型应该是依附关系，策略(令牌、速率、并发度等)及管控指令的下发应该通过数据控制面适配层来推送；流控的最佳集中控制点在数据面的通讯边车模块(可感知提供方的受压-主动/被动，可反压传导至服务请求方)；减少业务应用侧的耦合，应该通过接口形态反压传导到业务应用程序并联动控制；可以支持直接业务应用侧的流控手段，但前提是与平台内基础模块的解耦。

 

l 通过加入埋点、数据监控，能及时发现系统出现的问题，及时预警，及时介入处理。

l 链路检测、跟踪应以端到端的形态体现，需要解耦应用侧与通讯数据面。

l 日志处理以Node为汇聚点(Pod, Container,进程)统一归并后流式归集，实时分析。

l 以多点，多维度，多形式进行系统平台内的指标监控、收集，健康检查等。

l 监控系统(状态、事件)，其它(存储服务)：解除节点内与节点外监控点的关联耦合。

. . . . . .

 

9.  高可用状态监测
监测分布式系统内的各个子系统，模块，组件的状态，用以异常控制、预警联动，故障隔离与迁移恢复等等。

l 单一Node内的状态检测由Node、容器级别的监测代理集中采集上报，同时避免状态信息在Node级代理间传播，基于结构化本质，也无需构建Node级的全互联链路。如此，加强了事件监测状态在Node内的内聚和Node间的松耦合，极大减少资源消耗。

l Node监测的事件状态上送到平台内状态归集中心集群节点(N+1), 并作异常事件检测和规则触发后的预警。对于异常事件状态，以及触发的点、面需综合权衡设计，将关联影响方降到最低以最小化事件扰动，原则应交由对异常事件具有绝对控制职责的模块且在关键点来决策联动。以致力于将能量消耗减少到最低限度，同时将消耗单位能量产生的熵提高到最大限度。

l 为区分事件的来源于Node、Container、进程，可引用事件状态机与即时探测模式。

l 为进一步解耦应用与技术面，通讯路由、信息传输应集中在剥离的通讯子系统解决。

l 系统运行时关注在异常事件及处理，要规划好分布式架构内的操作控制流、数据流及其关键路径，避免把正常事件当作常态化处理模式，避免数据的全量广播，避免系统的设计过度、冗余化可能，避免给整体架构带来复杂性，以至降低了系统稳定性、可靠性。

. . . . . .

 

10. 服务发布版本与灰度
服务相对较小，以服务为单元的测试、发布、编排及部署、升级会变得更容易、可靠。每个服务可独立于其它服务进行部署，因此，将更改频繁部署到生产中要容易得多。确保服务的领域数据模型的唯一性，基于版本的控制可强化服务以业务为语义及利于其生命周期管理。服务发布，迁移控制等所涉及的数据对象模型需体现在服务对象模型上。

 

快速可靠地迭代与交付软件，提升交付的敏捷以及故障恢复效率。传统组织中部署频率低，交付的时间很长。相比之下，DevOps组织经常发布软件，生产环境问题要少得多。

 

灰度发布，服务实例迁移尽可能实现自治，减少对其它模块的过多耦合依赖。

减少操作控制、目标状态的不必要的传播、交互的环节，贯彻简单至上原则。

降低控制流，策略传递，信息传递，事件通知等等的用力面、传播面，设定最佳处理点。

交互操作的用语尽可能与服务相关用语具有区分性。

 

11. 资源高利用率、低使用率
自身依赖组件/模块是否与系统自身集成部分重复，应以复用优先、资源利用最大化为原则。

平台内、模块间的操作控制、事件/状态触发、数据传输，接口调用等，交互环节简单化。

给予分布式系统内关键/核心模块、子系统充足的资源，避免成为全局热点。

资源的低使用率要从顶层架构上来设计，消除无用模块、组件或通过归并方式达到资源分配的最小化、利用率最大化。

分布式系统内运行时的资源消耗，要规划、建立运行时模型，涉及控制、数据、资源等等。

避免分布式集群环境内的全网/区域全交互的订阅，数据推送，事件广播模式等。
