http://3ms.huawei.com/km/blogs/details/8705277

软件设计杂谈之二

从抽象到面向对象

 

引言

         在上一篇《从领域驱动出发谈软件设计》中，我们分析了领域驱动设计的思想和由来，以及主要过程和思路。在软件设计的整体过程中，最为关键的环节，是对软件模型的设计，即从领域模型到软件模型的映射。本文的内容，将针对这个主题，谈一谈为什么要进行抽象，什么是抽象，如何进行抽象，以及面向对象设计的好处，思维方法，和其中的一些简要实践，供大家一起参考和讨论。

 

一.   为什么要抽象，软件实现的乱与秩

我们往往对业务流程和其中的细节，都理解和把握的非常精准，在系统的上层框架和流程设计上，也能很清晰地反映出系统中各个业务流程的交互过程。但是在细节的软件设计和实现上，在模块内部甚至是模块之间的交互上，体现出来的往往却不再是那样的简洁和清晰，软件调用过程穿插往复、纵横交错。这样的软件开发和实现结果所反映出来的复杂性，是因为我们把直观上所理解的业务流程，以近乎一比一的形式将其从业务概念映射到了软件实体，以过程化的方法将其用编程语言描述了出来。

这就好比，将业务的每个流程看作是一根端到端的长线，一个特性和产品由许多这样的业务流程长线所组成，如果我们不以抽象的方法对其分解，而仅仅将这些长线直接叠加在一起来完成特性和产品开发，久而久之，我们所铸就的，将会是一个庞大而复杂的系统。当我们将来要去对其做一些修改和扩展时，每一个动作，都会是牵一发而动全身的效果，若没有在这万千头绪中抽丝剥茧的能力和深厚的历史业务开发经验，很难不触发问题，系统也因此渐渐变得越来越难维护，而新特性，也只能像湖泥巴一样，在历史的基础上层层堆叠，系统的开发和维护成本越来越高。如同图1中的概念美术馆，外观就像一个未经修饰的鸟巢，网络上对这个美术馆设计的总结是：“鸟巢是熟练的鸟搭的，这是新手鸟搭的”。软件设计如果也是这个方法，那么每一处的修改变动，都会引起整个系统的振荡。国家体育场鸟巢，从外观线条上看，其复杂性也很高，好像也看不出什么章法和设计，但从其设计过程和结构上看，却体现了模块和组件化的设计理念。

 

合肥美术馆效果图

图1.   “鸟巢”概念美术馆

 

鸟巢外观

图2.   国家体育场鸟巢外观

https://amuseum.cdstm.cn/AMuseum/olympics/aykjzt/images/kj_1_pic2.jpg

图3.   国家体育场鸟巢设计示意图

反观软件设计的凌乱，这其中所缺乏的关键之处，恰恰就是抽象和面向对象的设计过程和能力。从宏观上来说，我们所期望的具象的软件系统，应该是由众多抽象的对象和组件，在一定的合作关系上所搭建起来的。它们好似“乐高”积木一样的，由众多基本组件，以及一些特殊组件所构成的系统，而这个系统中的业务逻辑，则体现为其中对象实例的组织和合作方式。这里我们不用“模块”这个词，是因为“模块”在软件中代表的概念太大了，体现不出来其中的设计细节。基本的组件和对象可在系统的各个地方进行复用，而某些具有一定特殊性的组件和对象，是需要根据目标系统的特殊性来为系统定制的。这些关键的定制化的组件，起到了对系统予以质变的影响，它们加上众多基本的通用型组件，将构成我们“乐高”系统中不同的目标“玩具”系统，实现不同客户对各种类型“玩具”的诉求。通过对象化和模块化的软件设计，也便于我们更好地实现复用，以及对逻辑进行封装和隔离，更好地应用和创造多种多样的设计模式。

 

二.   什么是抽象

在谈到面向对象之前，我们首先来聊一聊抽象。抽象往往与模型相关，抽象的内容，需要通过模型表达出来，WiKi上对模型的定义是：A model is an informative representation of an object, person or system。简单来说，抽象是对问题理解之后，在头脑里沉淀下来的最直观的那个感觉，而要把这个感觉精准地表达出来，却并非易事。抽象首先是对本质的把握，然后用形式化的方式把这个本质表达出来。这里有两个过程：一是把握事物和过程的本质，二是要把这个本质表达出来。

把握本质，实际上就是识别出一个事物和过程中起决定性作用的约束关系，它们反映和决定了事物和过程的特性及规律。这些约束关系一般都不是单一的，而是多维并且是多层次的。最底层的约束关系最为本质，越往上的约束关系则体现的更多是对底层关系在特定场景下的衍生和变化。通常，我们需要将约束关系层层分解，将其中最核心和本质的内容，作为最核心的对象属性进行封装，其通用性和影响力也更高。同时，我们将其它更高层次的，随场景多变的约束关系叠加在基础的核心内容之上，形成在各个场景下的衍生抽象。而约束关系的维度，则体现为被抽象的对象在各个独立方面所受到的影响和制约，之所以是各个独立方面的制约，因为抽象所基于的任何一个单一维度都应与其它维度之间保持无关性，从而在本质上来对问题进行描述。

抽象，从另一个角度也分为对事物的抽象和对过程的抽象。对事物的抽象，是要识别事物最本质的特性和状态，把握能够影响和决定事物状态和特性的因素，将这些内容以相对静态的形式封装起来，例如面向对象软件设计方法中的类，类的属性体现为一个对象的关键属性和状态，类的行为则体现为一个对象具有的功能和职责。而对过程的抽象，则是要把握一个过程的规律，即可重复性的核心逻辑，识别出在这个重复过程中可以对结果产生关键影响的变化节点和因素，将这些内容以动态的方法体现和表示出来，从而通过软件来实现对规律的准确重现，就好比用机器学习的方法来实现对过程和规律的拟合与重现。

这些约束关系都来自于对象所要服务的场景，它们之间不应产生矛盾的推理结果，否则，一组矛盾的约束关系一定会在外部表现为场景中矛盾的需求。如果我们在进行抽象和设计的过程中发现了矛盾的约束关系，而这个矛盾的约束关系在业务需求的各个流程中又不存在，那么我们就需要反思和审视一下是哪里出了问题，是对问题的理解出现了偏差，还是对核心约束的把握上出现了偏差。比如，本层的约束关系是不是包含了不合理的内容，把本属于上层的约束关系，放在了底层的核心约束中，导致所设计的基本组件缺乏通用性而不能在多个场景下复用。理论上，当合理的约束关系被识别出来后，我们总是可以基于这样一组约束关系，来对业务需求中各个场景的流程进行顺畅而完美地推演，从而验证抽象的正确性。当然，这个过程并非易事，期间必然会出现各种各样的问题，在后面“抽象漏洞”的内容中我们会讨论一下出现问题的可能性和原因。




 

三.   如何进行抽象

抽象的进行，同样也可以从对事物的抽象和对过程的抽象两个方面来开展。对事物的抽象，是总结和提取出一个系统在不同层次上的静态内容，通过这些静态内容来构建系统的各个实体，我们可以称这些抽象出来的静态内容为系统中的静态对象，它们构成系统的基本元素。对过程的抽象，则是要总结出系统运行中的动态内容，即关系和规律，利用这些关系和规律来组织系统中的静态对象，从而和静态对象的行为一起构建出系统的行为和动态特征。

某些对象，往往不是从系统的运行过程中可以直接体会和观察到的，它是在抽象的过程中，通过对规律的总结和归纳而提取出来的，用以反映和承载规律和关系中关键的环节和功能，如在各种设计模式中所引入的非系统功能性对象。我们可以称之为动态对象，之所以是动态的，是因为对它们的定义，是从描述系统关系的角度出发的，因而，它们不与特定的静态对象直接对应，但在系统的运行过程中，却会与系统中的一类或几类静态对象发生关联，从而让业务中具有静态属性的对象参与到系统的运行关系和规则中去。




那么，如何来提取和识别系统中的对象呢？静态对象的识别相对比较容易，可以在业务流程的分析过程中逐渐地被识别出来，例如在描述问题和过程时所用到的各类名词，都可以作为候选的静态对象，它们是业务流程中承载着实际业务功能的逻辑实体。这些业务名词被识别出来后，还需要对其进行抽象化定义，即识别它们的共性部分，包括共同的关键属性和所应承载的通用关键行为。但是，仅有静态对象还不能完全对系统进行抽象和建模，静态对象所体现的是问题空间的组成成分，更为关键的，是对系统中所体现规律和关系的把握，即动态对象的识别和抽象。要准确地识别和刻画出系统中各个静态对象的关系和系统运行的规律，必须要对系统的所有运行过程进行仔细地分析和归纳，提炼出这些运行过程中静态对象之间的合作关系，以及那些在关键环节上的控制逻辑，将这些内容识别和提取出来。比如，如何决定运行过程中的下一步行为和关联对象，这个决策的逻辑和依据是什么。抽象的核心是对关键行为和关系的抽象，因此，我们要想办法把所识别出来的合作关系和控制逻辑通过一定的形式表达出来，而这时就需要创造性地构建出系统中所需要的动态对象了，用它们来管理之前识别出来的静态对象。此时，根据需要，可能还会对这些静态对象进一步抽象，以便使其满足动态对象的管理需求，使它们能够融洽地合作，例如对抽象多态行为的定义，让这个抽象的多态行为参与到核心的运作逻辑中。从这个角度来说，软件设计中不同的设计模式其实就是对系统中体现出来的不同关系和规则的实现方式。

如果从数学的角度来形式化地描述这个抽象的过程，就是要去找到问题空间的约束关系，得到描述关系所适用的关键变量和公式。我们所要做的，是识别出一个系统由哪些变量所决定，而且，这些变量是以什么关系来决定这个系统的输出结果的。然而，我们所面临的需求空间，却往往不是一个线性的问题空间，像解线性方程组那样通过简单的方法便可找出其约束关系。实际的需求空间要复杂得多，面临多种设备形态、应用环境、分布式场景、硬件选型、性能、支撑系统等多种变化因素的制约。极大多数时候，它更像是一个复杂的非线性方程组，那么，如果把我们利用软件所要设计和解决的问题和需求比作这样一个数学问题，有什么样的概念化的方法和步骤可供参考和借鉴呢？

一个可行的方案便是对其进行逻辑分割，分而治之，对每一个子域求解其特征关系，然后用各个子域的特征关系，对问题空间进行拟合。最初的逻辑分割便是识别问题的子域，而一个业务流程可能会涉及到多个逻辑子域，同时，在各个逻辑子域中，通常又会有多个业务流程的参与。这时需要对逻辑子域中的核心规律进行把握，并通过软件的方法予以表达和封装，使其适用于不同的相关场景和业务流程。面向对象技术，是最好的体现和描述这一关系的方法，因为抽象之后的对象，体现的是它们的共性，屏蔽了业务和场景的差异，这些共性中所体现出来的属性和行为，便是描述它们之间关系时所需要访问的核心数据和接口。根据关系的特征，予以相关的设计模式，便可很自然地将它们用软件地方法表现出来。一些通用的特征关系，都已有相应现成的设计模式可供参考，而与特定应用领域相关的特征关系，则需要将通用的设计模式与特定领域的特征相结合，形成与行业领域相关的设计模式。

可以把问题域比作一个如图4的二维空间，图中的红色标记点是在不同场景和流程下目标系统所期望得到的结果。该空间显然无法用一个统一的特征关系进行描述，但我们可以根据其在不同区域体现出来的特征将其划分为不同的逻辑子域，在不同的逻辑子域中，通过一些现有的关系进行归纳，而一些不易归入某个逻辑区域的特征，可以通过特殊的具体方式予以实现。接下来的问题，是如何将这些分散的逻辑关系组织成一个有机的系统整体，这取决于系统中一系列过程所经过的位置和次序，也就是每个流程需要哪些逻辑域的参与，这些逻辑域应该如何配合，这也是系统中更高层的控制逻辑。例如，一个在E区域的输入条件T，可以按照各个逻辑域之间的先后顺序进行串行处理，或者在某个区域内部，依据某些条件跳转到一个具有交叉合作关系的逻辑区域中。在这个设计过程中，上层的控制逻辑和关系，应尽量避免对下层对象自有特殊属性和行为的依赖，而应依赖于下层从对象中所提取出来的公共特征和行为。在这个过程中所完成的对静态对象的进一步抽象，是基于控制逻辑出发的，较初期静态对象识别和定义更为高层的系统抽象，而得到的是系统中最基础的静态对象，是多数静态对象的根。



图4.   对问题域的抽象

 

从软件设计对目标系统的拟合过程中，也可以反映出设计中的另外一个问题，即抽象的粒度和层次。如果在一个较高的逻辑层次上系统表现出巨大的复杂性和不确定性，在这层对系统中的各个基本元素之间的关系和规律进行直接抽象是不现实的，即使做了这样的抽象，该抽象的适用性也会很差。但是，如果因此而不对系统进行抽象，那么软件就会表现出过拟合的状态，系统将呈现出由一个个端到端的业务流程而交织起来的状态，久而久之，开发出来的目标系统也将极为复杂并难以维护，其结构的稳定性和适用性都会很差。这时，就应该找到合理的抽象层次和粒度，对规律性的内容加以抽象和封装，而将多变的内容留在封装的外面。这也是面向对象软件设计中的稳定抽象原则SAP(Stable Abstractions Principle)[3]：稳定的关系应该是抽象的，不稳定的关系应该是具体的。

那么，对于抽象的合理性如何进行衡量和把握呢？合理的抽象，会让系统的耦合性降低，所谓的低耦合性，就是当系统中的一个元素发生变化（扩展）时，其它的元素无须感知和响应，同时，任何一个元素，都只和最少的元素发生关联，减少不必要的交互。这样的一个系统，如果用熵的概念去描述它，应该是熵的最大化状态，即最稳定的状态。熵的概念来自于热力学第三定律[7]，形式上可以定义为，可以概念化地描述为：一个系统的熵，由其可能出现的状态和概率决定。当系统可能出现的各种状态的概率趋向平均时，这个系统的熵最大，系统最为稳定。当我们根据所识别的事物和过程的本质定义出系统中的静态对象、动态对象，以及系统中的规律和控制逻辑时，我们也就同时定义出了整个系统中的约束关系。那些体现静态对象本质特性的约束关系将被封装在我们所抽象出来的对象和组件的内部，并且随着组合地形成，层层内聚，形成各自中较强的内聚力。而对象和组件之间，则表现为相对较弱的作用力，即可搭配和组合的非强相关性，不同的组合搭配，将完成系统不同的功能和形态。而不是像在一个拥有巨大张力的系统中，任何一个部分的变动，都可能会造成系统失去平衡状态，从该点被撕裂开来，为了这个小小的变动，你可能需要在这个变动的周围打上一个大大的加固补丁，以防止系统的失衡。所以，从总体上来看，合理的抽象，是要在一个系统中找到合理的逻辑分割点，从而让系统的对象和组件之间尽量始终保持弱作用力的关系，从系统中任何一个组件和模块的内部来看，这个逻辑也同样适用。

抽象漏洞。在软件抽象的过程中，抽象漏洞几乎是难以避免的，这就造成了设计的返工和优化过程。通过上面的分析，抽象漏洞大致可以归结为两条主因：一是对过程的遗漏，包括对主要过程的疏漏以及对过程中某个关键环节的疏漏，造成对系统约束关系把握的不足，这其中还有另外一个可能的分支因素，就是对未知需求的预见性和可扩展性不足。二是对问题理解的深度不当，如抽象不足或过渡抽象，因而丢失或包括了一些系统中必要或无须的特性和因素。不过，有些内容可能是我们在抽象的过程中有意排除在主要关系之外，而决定通过具体方法来去覆盖的。如何避免和修复抽象漏洞呢？正向来看，最重要的当然是要对问题的各个过程、场景进行充分的分析和准确到位的理解。另一方面，在进行抽象设计时，尽量做通用化的属性归纳和行为定义，而将具体的细节隐藏在每个独立实现的内部，提供一个通用化的封装，基于接口以及继承和多态的设计，也是这个的逻辑。这样，即使后面发现了遗漏的逻辑需要补充的时候，也会避免与现有抽象逻辑和设计的冲突，这也是面向对象设计中开闭原则的体现。反向来看，避免抽象漏洞则需要对设计逻辑在付诸实施之前进行推演和模拟，来验证目标问题空间中每个过程和环节的需求是否在所设计的逻辑系统中得到了充分的考虑和实现，系统工程理论[4][5][6]在这方面有成熟的模式和实践方法可供参考。

 

前面的内容我们分析了在解决复杂问题的过程中，抽象的重要性以及如何抽象，接下来我们从软件设计的角度，来讨论一下如何在软件设计的过程中将抽象的思想方法付诸实施，即面向对象设计。

 

四.   为什么要采用面向对象设计

从直观的理解上来说，面向对象是一种仿生的设计方法。世间万物的构成，都可以看作是由不同的对象所构建起来的。电子、中子和质子构成了具有不同特性的元素的原子，不同原子的组合又构成了不同的分子，不同的分子以特性方式的组合又构成了不同性状的物质，不同的物质以特定的方式混合在一起又会形成新的具有特殊物理特性的结构性物质，而这些物质又构成了千变万化的世界。所以，将我们要予以设计和实现的目标系统，通过不同层次和粒度的对象进行定义，也将产生这种千姿百态的组合效果，来满足我们对系统的不同需求，为系统的设计和实现提供最大的灵活性，就像由众多的乐高组件所搭建的千变万化的玩具世界一样。

从理论上来说，当一个系统中的各个组成成分之间的作用力最小时，系统的熵[7]最大，系统的可变性和灵活性也最大，因为系统中任何一处受到的来自其它部分的外作用力都是相对均衡的，系统处于平衡的稳定状态，这些对象可以被组合而表现出不同的整体特征。我们所要做的，就是要将尽可能地去识别和提炼这些众多的基本元素和对象，用它们来完成我们对目标系统的构建，同时来尽可能保证这个系统的灵活性和稳定性。




 

五.   面向对象的思维方法

一个软件系统，总是要去完成特定的任务集合，而这些任务来自于我们的需求。当我们分析需求任务时，会很自然地把它的每个场景通过一步步的过程进行展现。过程化的描述是对须完成的任务进行分析的自然输出，而在过程描述中，每一步交互所关联的主体和客体就是过程中的对象。面向对象的设计，是将过程中的实体视作一个个活动的对象，它们不仅拥有特定的信息和数据，还有其必须履行的职责和行为，而这些对象之间的良好地合作，就构成了一个动态和稳定的系统。而如何识别和抽象从顶层到底层各个级别的对象，以及定义它们的合作关系，就成为面向对象设计的核心任务。

在早期的过程化软件设计时期，我们总是习惯于把对过程的理解转化为一个个具体的函数，比如PASCAL语言中的procedure，通过函数内部的流程，以及函数之间的调用关系来实现我们所理解的过程和逻辑，然后，再根据函数和过程的需要定义出所需的数据结构用来承载一些常态的信息。而面向对象设计，则将这个过程稍微反转了一下，虽然也是从流程分析入手，但首先要做的却不是直接将过程转化为一个个函数，而是识别和分析过程中所呈现出来的每个概念和逻辑实体，将它们以对象的形式定义出来，这体现为对两个其核心要素的归纳和刻画，即哪些属性和行为应属于一个逻辑实体，属性描述了对象的特征，行为描述了对象的职责。如上文所述，对象包括体现系统元素的静态对象和反映系统控制逻辑和关系的动态对象。然后，我们把所理解的过程和规则，转换到基于这些对象的合作上来，也就是说，一个流程需要什么对象来参与，对象之间通过什么接口进行合作，需要访问各自的什么数据即对象属性。




 

六.   面向对象实践

对象的定义和设计来自于抽象的过程，而抽象则体现在对问题的分析过程中，上文中已经做过一些描述，这里仅对面向对象设计中的一些实践经验进行简要的概述。

1.      对象的生命周期

不同于过程化设计中的数据结构，所有的对象一旦被定义出来，都有其生命周期。随着系统的运行，哪些对象在什么时候创建，什么时候销毁，创建和销毁的规则和条件是什么，需要哪些准备数据。就像是一场戏剧中的演员，何时登场何时退场，以及以什么样的装扮登场，什么样的姿态退场，导演都需要有精心的安排，而系统的设计师就是这场戏剧的导演。

2.      封装的程度

面向对象的设计中，一个重要的概念就是封装，将数据和逻辑封装到对象的内部，通过对象的行为展现出来。外部只能通过对象的接口对其进行数据访问和控制，而不能直接访问其内部的内容，通过这样的方法来屏蔽细节，减少耦合。封装的过细，带来的问题是调用层次的增加，效率的降低。封装的不足，则耦合性增强，内部数据结构的改动和逻辑变换，都会在调用者一侧被感知。那么封装到什么程度合适呢？我的个人经验是实用主义原则，不做过渡的封装。如果一个逻辑实体内部的某个功能不会有预见性的变化需求，且外界也不会对其有直接的感知，而只会调用容器的通用接口来访问其中的某个对象而无须感知细节是如何实现的，比如容器中用不同的算法来管理其中的对象，则这时便没有必要将算法作为一个独立的对象封装起来嵌入到容器对象的实现中。但如果我们有或者预见了这样的需求，甚至是需要去支持在运行时对算法的动态替换，则需要考虑这样的设计，并且考虑如何将容器中的对象实例在不同算法的数据结构间进行转存。

3.      单一职责和单一接口

我们都知道设计模式六大原则中的单一职责原则，它有两个层面的涵义，一是类的单一职责，一是接口的单一职责，我们这里要讨论的是接口的单一职责。如何衡量和把握接口的单一职责呢？这里先举个例子：socket (int family, int type, int protocol)，这个函数用于创建一个socket以便进一步建立数据通信。但这个接口中的参数family有5种取值类型AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE、AF_KEY，type参数有4种取值类型SOCK_STREAM、SOCK_DGRAM、SOCK_SEQPACKET、SOCK_RAW，protocol参数有3种取值类型IPPROTO_TCP、IPPROTO_UDP、IPPROTO_SCTP，这么多的类型组合构成了多种socket的可能性，那么这样一个接口的设计是否违法了单一职责原则呢？理论上，是否将每个类型单独提取作为一个接口来实现更为方便和清晰呢？我们也通过另外一个例子来回答这个问题，假设你去一个机构或部门办事，在前台简要咨询后告诉你去二楼，结果来到二楼，你发现有好几个办公室，每间办公室门口都悬挂了相似的职责门牌，你也搞不清楚自己到底应该去哪里，于是一个一个地去阅读和咨询它们的详细说明。这时你会想怎么改进这个“接口”设计呢？是否一个更为合理的方式是，对拥有近似职责的功能，定义一个统一的“接口”，这个“接口”的描述必须具有明确的功能辨析性，让来访者非常容易地根据自己大致的需求便可直接找到，进来之后，再根据来访者的详细需求进行具体的逻辑划分处理呢？

对象对外界的接口应尽量简化，相似度高的功能应尽量统一在一个抽象接口上，接口内部可以通过参数等进行处理流程的划分，以简化对象对外的接口，类似于C++中同一个函数名以不同参数的形式实现重载。

4.      同样的事情，只在一个地方做

在软件设计和开发的过程种，由于经验和理解深度的递进，我们经常不能在开始就一次对系统抽象到位，例如，会发现类似的逻辑在其它地方已经用某个具体的方法实现了，而在另一个过程中又需要用到，但在开始并没有认识到这个逻辑在不同场景中的通用性，也没有进行抽象化的设计和实现。这种潜在的重复逻辑，便是我们进行关系抽象的输入因素，通过什么样的方法和模式，将它们之中重复的逻辑提取在一个共同的控制关系里，并支持对不同场景中不同对象的兼容，以实现逻辑的复用和封装。也就是说，同样的事情，只在一个地方去做。

5.      识别主要矛盾来分解和定义系统

设计系统中的一个业务流程，对流程中的主要逻辑模块进行划分和定义，还相对容易，随着流程的增加，系统的复杂性也开始激增，这时，所面对的制约因素也越来越多，再往下细分时，往往会感觉到很难快速地找到一个合理的逻辑和职责划分边界，怎么做都有道理也都有问题。这就有点像你去规划磁盘的存储目录，或是管理你的浏览器收藏夹，顶层的文件目录和文件夹功能的定义总是很容易，而越往下，越难准确定义和区分文件夹的功能属性，遇到有些新的文件或者网页时，也不太好权衡到底该放在哪里合适，这是由于一个具体对象可能具有的属性和信息太多。

这里，我们首先要权衡的是，哪个维度的信息对你最重要。系统引入的需求流程越多，所产生的制约因素也越多。我们首先要仔细权衡，系统设计的目标和职责是什么，闭上眼睛，放松下来，把这几十种的需求流程，以及它们所涉及到的逻辑概念，在头脑里过滤一下，哪些是最核心的，具有顶层控制力的因素，是影响我们对某个逻辑概念进行抽象和功能定义的核心因素，再把几种方案制定出来，仔细地推敲、分析和讨论，这是在一个系统和模块架构设计的初期所要做的关键事情，而这样的工作，随着细节的深入，通常需要反复多次，才能形成一个阶段性的稳定状态。

而这其中，最核心的内容，就是对每个遇到的问题，进行本质性的思考：根据对于本质属性和目标方向的把握，从众多维度的制约因素中，找出各层中那些决定性的因素，以此来推进各层次的设计。对于本质属性和方向的把握，可以借助类比或极限推理的思考方法，寻找到一切可以类比的东西，来帮助自己更好地理解和分析，从自然界的事物中，从既往已有的各种优秀设计中，从前人的经验总结中，寻找类似的经验，最后形成自己的分析和论证结果，看看能不能说服自己，解决自己之前的那些困惑和难点问题，再拿出来和大家讨论。极限推理，就是假设系统在某个设计方向上的一种合理极限状态，看在这种状态下，相关的行为逻辑应该如何定义，应该考虑和满足哪些约束。

 

樊伟 f00543124

2020.08

 

References:

[1].    场馆建筑创新设计, https://amuseum.cdstm.cn/AMuseum/olympics/aykjzt/kj_1.html#ad

[2].    The Stable Abstractions Principle, https://link.springer.com/chapter/10.1007%2F978-1-4842-4119-6_11

[3].    Model-based systems engineering, https://en.wikipedia.org/wiki/Model-based_systems_engineering

[4].    Model-Based Systems Engineering: An Emerging Approach for Modern Systems,
https://cs.anu.edu.au/courses/comp3530/readings/05722047.pdf

[5].    A Primer for Model-Based Systems Engineering,
http://www.ccose.org/media/upload/MBSE_Primer_2ndEdition_full_Vitech_2011.10.pdf

[6].    Third law of thermodynamics, https://en.wikipedia.org/wiki/Third_law_of_thermodynamics
