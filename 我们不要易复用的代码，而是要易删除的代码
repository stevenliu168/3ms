http://3ms.huawei.com/km/blogs/details/2038337

我们不要易复用的代码，而是要易删除的代码


读https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems后的一些翻译和感悟：

在以前的编码的时候，心中总有一个愿景：编写的代码是可完全可扩展，可复用的（开闭原则），尤其是在面向对象编程的时候，使用了很多设计思想和设计模式，添加了大量的接口抽象，中间类，继承体系。这样的代码看起来的确很炫酷，也很“容易扩展”。

 

今天下面从另一个角度来看代码的编写原则，就是要让代码易删改，而不是复用代码。

我们程序员每写一行代码，后面都需要去维护它，为了提高可维护性，我们往往就会让代码可复用。但是可复用的代码就会出现问题，就是有什么问题需要修改怎么办？

比如我写了一个API要让别人来使用，如果很多人都用这个API，某一天我需要进行修改，那么代码修改量会很大，并且兼容性，依赖关系这些麻烦都很难处理。

我们将程序代码行看成“耗费了多少行代码” ，那么要降低代码的维护成本，就是删除这些代码，开发可丢弃的软件，而不是总是要去复用这些代码软件。

 

那么怎么写出容易删除的代码：

l  重复你自己以避免产生模块依赖性，但是不要重复管理这些代码。

l  把自己的代码进行分层， 在易于实现但是不易于使用的模块的基础上构建易于使用的API。

l  代码拆分，将难于实现并且很容易改变的模块相互隔离。

l  不要把每个选项都写死，容许运行时做改变。

l  不要试图同时去做上述所有的事情，或许你在一开始就不要写这么多代码。

 

1      Step 1：（避免写代码）
数量级越大的代码越能折磨程序员，并且要进行替代，重构需要花费大量的精力和投入。也许少写几行代码并不会节省什么工作量。但是无论如何，最容易删除的代码就是初期就可以避免写出来的代码。

2      Step 2：（复制粘贴代码）
可复用的代码并不是你一开始就可以写出来，而是先有大量的示例代码以后才重构抽取出来的，写代码的初期你是无法预料什么样的代码是最适合可复用的。

复制粘贴一些代码若干次，是没有问题的，一点点冗余是健康的。我们不需要每次复制粘贴的时候就写一个库函数，起一个特定的函数名，一旦把这些代码编程的函数API，改变起来就比较麻烦了。

删除函数内的代码永远比删除一个函数要简单。

3      Step 3：（不要复制粘贴代码）
如果某段代码复制粘贴很多次了，那么是时候提炼抽取一个函数出来了，比如某些无状态的函数，一些涉及环境变量等全局信息的函数，再把这些函数放到一个我们最喜欢的util的文件夹中。（注意，util文件夹中要根据功能划分不同文件）。

通用性越强的代码越容易复用，越不容易被改变和删除，比如日志管理，内存管理等，还有一些接口简单的集合类也不会删掉。

我们要努力将代码中难以删除的部分与易于删除的部分分隔得尽可能开，而不是使所有代码都变得易于删除。

 

4      Step 4：（写更多的模板）
即使我们可以使用公共库来避免代码的复制粘贴，但是使用这些库的函数还是需要复制粘贴，最后也会出现大量的相似的代码。这些代码有另外一个名字：模版（boilerplate）。

模板和复制粘贴不一样的地方就是每次使用模板都需要在不同的地方就一些改变，而不是完全相同重复的东西。

很多库适合使用模板：比如网络协议，程序传输格式（比如HTML5 Boilerplate）。这种代码是很难删除的，因为网络通信和交付是必须的，并且这种代码不要和业务逻辑混合。

我们尽可能将变化频繁的部分和相对更稳定的部分隔开。按照最小化库的依赖性或责任，即使我们必须通过模版来使用它们。

你会写更多的代码，但是这些多出来的代码都是在易于删除的部分。

5      Step 5：（不要写模板）
当某个库需要迎合所有要求的时候，模版的作用最为明显。但是有时候重复的东西太多了。是时候将一个弹性很大的库用一个考虑到了策略、流程和状态的库打包起来了。开发易用的 API 就是将模版转换成一个库。那么用一个考虑到了策略，流程和状态的库打包若干种库，这个时候就可以抽取一个更易用的API。

这个类似于设计模式中façade模式，将内部繁琐的流程进行封装，对外仅仅提供一套更简单的接口，隐藏内部细节。

将一个第三方库打包起来通常也是很好的实践，即使它们不是协议类的库。你可以写一个适合你的代码的库，而不是在整个项目中都锁定一个选择。这样底层随时可以换掉第三方库而不用修改上层接口。

分层更多的是为了使那些很难删除的代码易于使用（在不让业务逻辑污染它们的情况下），而不仅仅是关于写以后可以删除的代码。

 

6      Step 6：（写一大段代码）
你已经复制粘贴了，你已经重构了，你已经分层了，你已经构建了，但是代码在最后还是需要做一些事情的。有时候最好的做法是放弃，然后写一大段垃圾代码将剩余部分弄在一起。

业务逻辑代码是让人讨厌的，有着大量的边界情况考虑，还需要写很多快速而肮脏的hack代码（也就是我们经常说的代码中的特殊处理），这个是没有问题的：通过捷径来节省大量的时间。

我们可以先把一大段代码都写出来，并且写在一起，开始的时候不用过于关注可扩展性可复用性，因为删掉一个大的错误比删掉18个小的交织在一起的错误更容易。编程都是探索性，不要总想着一次性作对，犯几次错误以后再去迭代解决可能更快速。

这种探索性的编程更充满趣味性和创造性，我们不要总是先写框架再写代码。上来可以大胆的写一堆乱七八糟的代码。因为最开始没有知道怎么样拆分模块的。

我们在第一次尝试时都应该犯新的错误，接纳新的风险，然后通过迭代来慢慢晚上，一个专业的软件开发者的过程就是不断积累后悔和错误清单的过程，我们总是在失败上学到东西。举个例子来说，若干年后，你可能不知道好代码是什么样子，但是对于坏的代码却记忆犹新。

一次行删掉所有的代码比一段一段的删掉更容易。

 

7      Step 7：（把你的代码拆分成小块）
大段的代码是最容易写的，但同时维护起来也最为昂贵。一个看起来很简单的修改就会以特定的方式影响代码库的几乎每个部分。本来作为一个整体删除起来很简单的东西，现在变得不可能去一段一段地删除了。

就像我们根据相互独立的任务来将我们的代码分层一样，从特定平台的代码到特定领域的代码，我们同样需要找到一种方法来梳理出顶层逻辑。

我们根据代码之间没有共享的部分来拆分代码，而不是将其拆分成有共同功能的模块。我们把写起来、维护起来，或者删除起来最让人沮丧的部分互相隔离开。

我们构建模块不是为了复用，而是为了易于修改。

当一个模块做两件事情的时候，通常都是因为改变一部分需要另外一部分的改变。一个写得很糟糕但是有着简单接口的组件，通常比需要互相协调的两个组件更容易使用。

错误处理和恢复最好是在代码的外层进行。这被称为端对端（end-to-end）原则。端对端原则说在一个连接的远端处理错误比在中间处理要更容易。即使在中间层进行处理，最终顶层的检查也无法被省去。如果不管怎样都需要在顶层来处理错误，那么为什么还要在里层去处理它们呢？

首先我们将我们的代码分层，但现在其中的一些层要共享一个接口：一系列有着不同实现的相同行为和操作。好的松耦合通常就意味着一致的接口。代码中模块化部分使得代码可以像积木一样可以拼凑一起，但是一个健康的代码是允许存在一些冗余的，这样可以使得可移植的组件之间的距离恰到好处，不会把程序员套在里面。（松耦合的例子：比如使用了中间件，使用了过滤器，使用了管道等）

松耦合的代码不一定就是易于删除的代码，但是它们替代和修改起来都会容易得多。

8      Step 8：（持续地写代码）
如果在写新代码的时候不需要去考虑旧有的代码，那么测试新的想法就要容易很多。如果不要求你写出微服务架构，那么如何在版本开发的时候同时可以支持1~2个试验呢？

在业界常见的方法就是Feature toggle（Feature Flag ，Feature Branches）（https://en.wikipedia.org/wiki/Feature_toggle），这个可以让你的软件在不重新部署的情况下改变应用的行为。

 

为了实现Feature toggle，一般需要将功能进行模块划分，每一个模块都是可以独立上线，相互之间是轻松合并的，如果某个模块或者组件出现问题，可以快速回滚或者删除。所以处理代码不仅仅是开发新的功能，同时也是抛弃掉旧的功能。要真正写出可扩展性的代码，那么必须是几个月以后你能把所有的事情做作对，如若不然，你的代码就需要继续试错，直到稳定。

 

上面说的“分层、隔离、共同的接口等”并不是有关写出优秀的软件的，而是关于怎样开发一个可以随着时间而改变的软件。

你不必要将代码全部抛弃，但是你需要删除某些部分。好的代码并不是要第一次就做对一件事。好的代码是那些不会造成障碍的遗留代码。

简单来说，就是在开发新特性的时候，新老特性之间的影响要最小，特性可以快速切换。

9      总结
从上面的8个步骤可以看出，写出容易删除的代码和可复用易扩展的代码是不冲突的。

 

我们的代码中有多少代码是不需要写的，主要是多余的功能代码，过度的模块设计。有时候简单明了的代码架构比高可扩展高复用的代码更实用，谁知道你的代码什么时候会扩展呢？

我们很多程序员追求很高的代码架构，编码的时候希望几年之后的代码变动都可以复用现在的代码架构，我觉得这有点想多了（虽然我有的时候也是这么想的，也有意识无意识的使用很多设计模式来做无用的抽象），可能N年以后这部分代码也不会扩展，也有可能扩展的时候现有代码架构完全不能满足诉求。

所以可复用的代码并不是一开始就写出来的，也就是不要过度设计，只要在出现很多重复类似代码时候，就可以开始重构，这样抽取出来的模块和API才是更有意义的，才是真正可复用的代码。

好的代码，可扩展可复用的代码都是不断的优化重构出来的，而不是刚开始模块设计就可以决定好的。

总的来说，只要把代码架构按照分层的，模块松耦合的，那么不变和通用的部分就会慢慢沉淀，这些代码就是不会轻易删除的，是可复用的，而其他的比如业务代码就是易变的，那么不变和易变之间做到隔离，你的代码架构就是易删除的。

 

并且现在流行的微服务架构也是推崇服务小，并且易替换升级，微服务是容易替换的服务，只需要通过无状态的通信接口和彼此独立的数据存储来保证服务之间的松耦合。
