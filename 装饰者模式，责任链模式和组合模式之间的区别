装饰者模式，责任链模式和组合模式之间的区别
前言
对于喜欢看设计模式类图的兄弟就发现，在设计模式中，有三个设计模式的类结构图特别类似，如果不仔细看，都察觉不到差异，那就是装饰者模式，责任链模式和组合模式。

组合模式
undefined

装饰者模式
undefined

责任链模式
undefined

组合模式 VS 装饰者模式
组合模式和装饰者模式都是基于递归组合的，所以在结构图上面是如此类似。但是这两种模式的目的和最终结构形态确实完全不一样的。

组合式模式是描述了一种树状结构，然后添加树种任何节点的时候都不改变对外的行为，客户端永远都是统一的方式。
典型应用：
比如Windows的文件系统，文件夹和文件这种树状结构，就是一种组合模式， 文件夹和可执行文件对外表现的行为很多时候都是一致的，比如双击，右键单击，缩略图显示等，这样对于这样的处理的时候操作者就不用关心具体的实现，用统一的方式来处理文件或者文件夹。如果后面添加具有相同行为的对象时，客户端的操作都不用关心。

undefined

装饰者模式是描述了一种链状结构，然后通过在链式上面增加新的节点来增加新的对象职责，这样就避免了子类的急速膨胀。
典型应用：
在Java的IO的API中

BufferedInputStream bis = new BufferedInputStream(new FileInputStream(“abc.txt”));

这个时候你就是创建一个BufferedInputStream装饰者对象， 由BufferedInputStream来装饰FileInputStream

基于上面这个原理，你就很方便进行进行扩展，定义自己的装饰者。
比如我要实现一个功能，把输入流的所有字符串都变成小写的，那么只需要从FilterInputSteam派生一个装饰者出来：

public class LowerCaseInputStream extends FilterInputStream{}
使用的时候按照如下的方法构造就行：

InputStream in = new LowerCaseInputStream(new BufferedInputStream(new FileInputStream(“abc.txt”)))
下面这个就是类图描述
undefined

责任链模式 VS 装饰者模式
从表现形式来看，这种模式都是链式结构
装饰者模式前面已经说了，那么责任链主要是为了解耦消息的发送者和多个接收者。

装饰者在一个链上调用的时候不会出现中断，但是责任链却可以在任何时候中断链，完成调用。

所以装饰者是用来动态增加类的新职责，而责任链用来解决动态增加行为的执行者

责任链从类结构可以看出来，是有闭包特性的，一旦进入链里面，就无法在出来，但是装饰者和组合模式却可以

责任链的典型应用场景：
比如公司的请假流程，员工，直接主管， 上级主管之间在处理请假的时候，可以根据员工的请假天数进行动态选择权签人，这就是一个典型的责任链使用场景

总结
这三种模式都是运用了对象的基本组合来完成的，但是在使用场合和目的上却大相径庭

组合设计模式的使用场合
想表达的是对象的“部分-整体”这种树状的层次结构
希望用户忽略组合对象与单个对象的不同。用户统一使用组合结构中的素有对象。 解耦了客户端与负载元素的内部结构
装饰者模式的使用场合
需要为某个现有的对象动态增加一个新的功能或者职责
当某个对象的职责经常发生变化或者动态增加职责，避免因此而增加继承子类的方式，否则会导致子类膨胀
责任链模式的使用场景
有多个对象处理同一个请求，具有由一个需要运行时来确定
消息有多个接受者，但是接受的对象不明确，那么就向其中一个发出消息，然后由其内部处理
同一个消息的处理对象可能会动态增加和减少
设计模式之间都不是孤立的，很多时候都是混合使用的，比如责任链可以是组合树上的一条链，装饰者用来装饰组合子等等。 我们这里不讨论这些设计模式后面的那些原则（那些是很重要的，那才是我们掌握设计模式的根本所在），我们了解了设计模式的使用场景，并且是用来解决什么问题的，那么很多时候模式都是自然而然出现的，不用我们可以照着类结构图去实现。
