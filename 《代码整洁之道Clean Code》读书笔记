http://3ms.huawei.com/km/blogs/details/7632513

1  前言
以前软件只要给客户提供想要的功能即可，也就是代码只要能工作就行，至于代码写成什么样，没人会去看，所以经常会认为客户不用管我写的代码如何，只管用就行了。但是就如同我们买一张桌子一样，我们通常会挑好的材料做的桌子，桌子里面的做工如何，而不只是看它表面是否漂亮，是否只满足桌子的外形而已，因为我们希望它耐用。放在软件上也一样的道理，大部分代码都不可能在未来完全不修改，客户除了关心你提供的软件是否能满足需求外，还希望你提供的代码能长久的运行，并且易维护，能在未来的发展中快速修改成满足未来要求的软件，也就是易演进，而不是一锤子买卖。只有好的代码（Clean Code）才更易于维护和发展。

建议开发人员都能认真阅读和体会一下《代码整洁之道Clean Code》（作者：Robert C. Martin）这本书，才真正了解什么是Clean Code，更理解编码规范中每条规范的来历，比起死记硬背一条一条编码规范来说，在懂了为什么之后能更好的记忆。当然这本书并未包括华为编码规范中的所有内容，但也包含了一些编码规范中未包含的内容，例如：如何做好单元测试，并举了一些实例如何将代码改造成Clean Code。

本文只是做了一些简单的笔记，要理解还是需要详细看一下该书。

2  通用规则
整理：

像对你的第一个孩子命名一样谨慎对每个变量命名。

整顿：

每段代码都该在你希望它所在的地方，如果不在那儿就需要重构。

清楚：

对于遗弃、无注释代码直接清除。

清洁：

开发组内形成一套统一的代码风格和规范。

身美：

自律，乐于改进。

重要注意：

写出可读的代码和写出可执行的代码一样重要。

整洁的代码只做好一件事。

时时保持代码整洁，如果代码在我每次签入时都比签出时干净，那么代码就不会腐坏。

  3  规范中涉及的概念
开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。添加新特性是通过扩展系统，而不是修改现有代码。

过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数；但难以添加新数据结构，如果要添加则需要修改所有函数。

面向对象代码便于在不改动既有函数的前提下添加新类；但难以添加新函数，如果要修改则需要修改所有类。

得墨忒耳律：模块不应了解它所操作对象的内部情形。方法不应调用由任何函数返回的对象的方法。

学习性测试：编写测试来遍历和理解第三方代码。

Given-When-Then表达方式：可以称之为经典三点论模板：Given 一个上下文，指定测试预设；When 进行一系列操作，即所要执行的操作；Then 得到一系列可观察的后果，即需要检测的断言。
F.I.R.S.T.规则：快速（Fast，运行快）、独立（Independent，相互独立）、可重复（Repeatable，可在任何环境中重复通过）、自足验证（Self-Validating，直接输出是否通过的结果）、及时（Timely，及时编写）。

单一权责原则（SRP）：类或模块应有且仅有一条加以修改的理由。

依赖倒置原则（DIP）：类应当依赖于抽象而不是依赖于具体细节。

  4  规范
   4.1 命名
所有变量、函数、参数、类、文件等都涉及命名，命名要体现本意（如果需要对名称进行注释则未体现本意）。类似的名称需要做有意义的区分，命名要取能读得出的词。要取能搜索的名字（不要太大众化），不要前缀，不要有废话。类名应该是名词或名词短语，不应当是动词；方法名应该是动词或动词短语。每个概念对应一个词，而不是在不同模块中对应不同的词。

   4.2 函数
要短小，不该大于100行，20行最佳，每行不应该超过150个字符（在一屏中能显示全，不用点击滚动条）。函数应该只做一件事，做好这一件事（判断函数是否只做了一件事，可以通过看是否能再拆成一个函数）。函数参数不要太多，三个以下最好（测试组合覆盖困难，超过三个封装为类，华为编程规范是不超过5个）。不要向函数传入boolean值。尽量避免使用输出参数，可以转换为类的方法。函数要么做什么事，要么回答什么事，不可两者兼得。使用异常替代返回错误码。消除重复。

   4.3 注释
尽量不要写注释，将注释需要表达的意思用代码来表达。注释要准确、更新。如下情况值得写注释：法律信息（版权著作权）、意图的解释（不一定是最好的解决方案，解释一下为什么这么干）、对于不能修改的代码、警示、TODO注释、重要、公共API的javadoc。

   4.4 格式
文件行数不要太多（不超过500行，小于200行最优，华为编程规范是2千行），不同函数、块之间用空行隔开，有关系的代码间不要有空行。不要把关系密切的概念放在不同的文件，避免使用protected变量。变量声明需尽可能靠近其使用位置，本地变量应在函数顶部出现。实体变量应该在类的顶部声明。如果某个函数调用了另一个函数，则应该放在一起，且调用者放在被调用者上面。推荐横向不超过120个字符（不用向右边滚动屏幕）。团队内使用统一的代码风格有助于相互理解，可以将规则编入IDE的代码格式功能中。

   4.5 对象和数据结构
对象暴露行为，隐藏数据。数据结构暴露数据，没有明显的行为。

   4.6 错误处理
使用try-catch结构更符合测试驱动（TDD）方法。给出异常发生环境的说明。可以定义异常类，简化代码。方法应避免返回、传入null值。

   4.7 边界
要通过测试来支撑学习、使用、替代第三方代码。在要调用的代码还没实现时先定义好接口。清晰的分割和定义边界代码上的测试。

   4.8 单元测试
TDD三定律：

1）在编写不能通过的单元测试前，不可编写产品代码；

2）只可编写刚好无法通过的单元测试，不能编译也算不通过；

3）只可编写刚好足以通过当前失败测试的产品代码。

测试与产品代码一起编写，测试只比产品代码早写几秒。测试代码和产品代码一样重要，也要符合编码规范的要求。单元测试让代码可扩展、可维护、可复用，测试使代码改动变得可能。

整洁测试的要素：可读性。分为构造测试数据、操作测试数据、检验操作结果。每个测试一个概念，符合given-when-then的约定。测试应遵循F.I.R.S.T.规则。

   4.9 类
符合单一权责原则。系统应该由许多短小的类而不是少量巨大的类组成，每个小类封装一个权责。符合OCP和DIP原则。

   4.10  系统
构造与使用是不一样的过程，应分开。方法：

1）将全部构造过程搬迁到main之类的模块中。

2）对于需负责确定何时创建对象，可以使用抽象工厂模式，但构造的细节要隔离在应用程序之外。

3）依赖注入（DI）、控制反转（IoC）。Spring框架提供了最有名的Java DI容器。用POJO编写应用程序的领域逻辑，在代码层面与架构关注面分离开，有可能真正用测试来驱动架构。系统需要领域特定语言（DSL），便于与该领域的专家沟通。

   4.11  迭进
简单设计规则：

1）运行所有测试，确保系统完全可测试能帮助创建更好的设计，测试消除了对清理代码就会破坏代码的恐惧；

2）不可重复，通过重构来消除重复；

3）表达了程序员的意图；

4）尽可能少的类和方法（优先级低）。

   4.12  并发编程
并发防御原则：

1）分离并发相关代码与其他代码；

2）采用synchronized关键字在代码中保护一块使用共享对象的临界区，严格限制对可能被共享的数据的访问，尽可能减少同步区域；

3）如果要使用数据则复制对象以只读方式对待对象；

4）线程尽可能独立。

并发的几个模型：

1）生产者-消费者模型（一个或多个生产者线程创建置于缓存或队列中，一个或多个消费者线程从队列中获取完成工作，队列是一种限定资源）；

2）读者-作者模型（一个主要为读者线程提供信息源，偶尔被作者线程更新的共享资源）；

3）宴席哲学家。

避免使用一个共享对象的多个方法，如果需要使用则可以锁定客户端或服务端。

测试线程代码：

1）将伪失败（偶发事件）看作可能的线程问题，不要忽略偶发事件；

2）先使非线程代码可工作，不要同时追踪非线程缺陷和线程缺陷；

3）编写可插拔的线程代码，可以在不同的配置环境下运行，测试可以打桩；

4）编写可调整的线程代码；

5）运行多于处理器数量的线程；

6）在不同平台上运行；

7）通过装置代码来试错（硬编码、自动化【例如：ConTest工具】实现装置代码）。

  5  启发
   5.1 不好的代码
1）注释包括不恰当的信息、废弃、冗余、糟糕、注释掉的代码；

2）需要多步才能实现的构建和测试；

3）函数中过多的参数、参数用于输出、布尔值参数、死函数（永不被调用）；

4）一个源文件中存在多种语言、明显的行为未被实现、不正确的边界行为、忽视安全、重复、在错误的抽象层级上的代码（应将所有较低层级概念放在派生类中，所有较高层级概念放在基类中）、基类依赖于派生类、信息过多、死代码、垂直分隔、前后不一致、混淆视听、人为耦合、特性依恋、选择算子参数、晦涩的意图、位置错误的权责、不恰当的静态方法、使用解释性变量、函数名称未表达其行为、未理解算法；

5）测试不足。

   5.2 好代码
1）推荐把逻辑依赖改为物理依赖、用多态替代if/else或switch/case、遵循标准约定、用命名常量替代魔术数、准确、结构甚于约定、封装条件、避免否定性条件、函数只该做一件事、掩蔽时序耦合、不随意、封装边界条件、函数应该只在一个抽象层级上、在较高层级放置可配置数据、避免传递浏览；

2）通过使用通配符避免过长的导入清单、不要继承常量（应该静态导入）；

3）采用描述性名称、名称应与抽象层级相符、尽可能使用标准命名法、无歧义的名称、为较大作用范围选用较长名称、避免编码、名称应该说明副作用；

4）测试使用覆盖率工具、别略过小测试、被忽略的测试就是对不确定事物的疑问、测试边界条件、全面测试相近的缺陷、测试失败的模式和测试覆盖率模式有启发性、测试应该快速。
